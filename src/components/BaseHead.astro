---
import { ViewTransitions } from "astro:transitions";
import "../styles/fonts.css";
import "../styles/global.css";

export interface Props {
  title: string;
  description: string;
  permalink: string;
  image?: string;
  type?: "website" | "article";
  publishDate?: string;
}

const {
  title,
  description,
  permalink,
  image,
  type = "website",
  publishDate,
} = Astro.props;

// Ensure the permalink is absolute
const canonicalURL = new URL(permalink, Astro.site).href;
// Use provided image or fallback to default social image
const socialImageURL = image
  ? new URL(image, Astro.site).href
  : new URL("assets/social.png", Astro.site).href;
---

<!-- Global Metadata -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width" />
<link rel="icon" type="image/x-icon" href="/favicon.ico" />
<link rel="canonical" href={canonicalURL} />
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;600;700&family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap"
  rel="stylesheet"
/>

<!-- Primary Meta Tags -->
<title>{title}</title>
<meta name="title" content={title} />
<meta name="description" content={description} />
{publishDate && <meta name="date" content={publishDate} />}

<!-- Open Graph / Facebook -->
<meta property="og:type" content={type} />
<meta property="og:url" content={canonicalURL} />
<meta property="og:title" content={title} />
<meta property="og:description" content={description} />
<meta property="og:image" content={socialImageURL} />
{
  publishDate && (
    <meta
      property="article:published_time"
      content={new Date(publishDate).toISOString()}
    />
  )
}

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image" />
<meta property="twitter:url" content={canonicalURL} />
<meta property="twitter:title" content={title} />
<meta property="twitter:description" content={description} />
<meta property="twitter:image" content={socialImageURL} />

<ViewTransitions />

<!-- This is intentionally inlined to avoid FOUC -->
<script is:inline>
  const root = document.documentElement;
  const theme = localStorage.getItem("theme");
  if (
    theme === "dark" ||
    (!theme && window.matchMedia("(prefers-color-scheme: dark)").matches)
  ) {
    root.classList.add("theme-dark");
  } else {
    root.classList.remove("theme-dark");
  }
</script>

<!-- Twitter Widget Script -->
<script is:inline>
  window.twttr = (function (d, s, id) {
    var js,
      fjs = d.getElementsByTagName(s)[0],
      t = window.twttr || {};
    if (d.getElementById(id)) return t;
    js = d.createElement(s);
    js.id = id;
    js.src = "https://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js, fjs);

    t._e = [];
    t.ready = function (f) {
      t._e.push(f);
    };

    return t;
  })(document, "script", "twitter-wjs");

  // Function to load Twitter widgets
  function loadTwitterWidgets() {
    if (window.twttr && window.twttr.widgets) {
      window.twttr.widgets.load();
    }
  }

  // Load on initial page load
  document.addEventListener("DOMContentLoaded", loadTwitterWidgets);

  // Load on Astro page transitions
  document.addEventListener("astro:page-load", loadTwitterWidgets);

  // Load when Twitter script is ready
  window.twttr.ready(loadTwitterWidgets);
</script>

<!-- Mermaid Script -->
<script type="module">
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  // Function to get current theme
  function getCurrentTheme() {
    return document.documentElement.classList.contains("theme-dark")
      ? "dark"
      : "light";
  }

  // Function to get Mermaid theme variables based on current theme
  function getMermaidThemeVariables(theme) {
    if (theme === "dark") {
      return {
        primaryColor: "#ff6b6b",
        primaryTextColor: "#f4f4f5",
        primaryBorderColor: "#ff6b6b",
        lineColor: "#a1a1aa",
        secondaryColor: "#18181b",
        tertiaryColor: "#09090b",
        background: "#09090b",
        mainBkg: "#18181b",
        secondBkg: "#27272a",
        tertiaryBkg: "#3f3f46",
        // Text colors for dark mode
        textColor: "#f4f4f5",
        nodeTextColor: "#f4f4f5",
        nodeLabelColor: "#f4f4f5",
        nodeLabelBackgroundColor: "#18181b",
        labelTextColor: "#f4f4f5",
        // Grid and border colors
        gridColor: "#3f3f46",
        border1: "#3f3f46",
        border2: "#52525b",
        // Section colors
        altSectionBkg: "#27272a",
        sectionBkg: "#18181b",
        sectionBkgColor: "#18181b",
        sectionBkgColor2: "#27272a",
        // Pie chart colors
        pieTitleTextColor: "#f4f4f5",
        pieOuterStrokeColor: "#f4f4f4",
        pieSectionTextColor: "#f4f4f4",
        pieLegendTextColor: "#f4f4f5",
        pieOuterStrokeWidth: "2px",
        // Gantt chart specific
        taskTextColor: "#f4f4f5",
        taskTextLightColor: "#f4f4f5",
        taskTextDarkColor: "#18181b",
        taskTextOutsideColor: "#f4f4f5",
        sectionTitleColor: "#f4f4f5",
        todayLineColor: "#ff6b6b",
        // Flowchart
        edgeLabelBackground: "#27272a",
        clusterBkg: "#27272a",
        clusterBorder: "#3f3f46",
        titleColor: "#f4f4f5",
      };
    } else {
      return {
        primaryColor: "#ff6b6b",
        primaryTextColor: "#333",
        primaryBorderColor: "#ff6b6b",
        lineColor: "#666",
        secondaryColor: "#f9f9f9",
        tertiaryColor: "#fff",
        background: "#ffffff",
        mainBkg: "#ffffff",
        secondBkg: "#f9f9f9",
        tertiaryBkg: "#f0f0f0",
        // Text colors for light mode
        textColor: "#333",
        nodeTextColor: "#333",
        nodeLabelColor: "#333",
        nodeLabelBackgroundColor: "#ffffff",
        // Grid and border colors
        gridColor: "#cccccc",
        border1: "#cccccc",
        border2: "#999999",
        // Section colors
        altSectionBkg: "#f9f9f9",
        // Pie chart colors
        pieTitleTextColor: "#333",
        pieOuterStrokeColor: "#333333",
        pieSectionTextColor: "#333333",
        pieOuterStrokeWidth: "2px",
      };
    }
  }

  // Initialize Mermaid with theme detection
  function initializeMermaid() {
    const currentTheme = getCurrentTheme();

    mermaid.initialize({
      startOnLoad: true,
      theme: "default",
      themeVariables: getMermaidThemeVariables(currentTheme),
      gantt: {
        titleTopMargin: 25,
        barHeight: 30,
        barGap: 4,
        topPadding: 50,
        leftPadding: 75,
        gridLineStartPadding: 35,
        fontSize: 12,
        numberSectionStyles: 4,
        axisFormat: "%b '%y", // Compact format: Jan '24, Feb '24, etc.
        useMaxWidth: true,
      },
    });
  }

  // Initialize on load
  initializeMermaid();

  // Function to render Mermaid diagrams
  function renderMermaidDiagrams() {
    // Try multiple selectors to catch different MDX rendering patterns
    const selectors = [
      "pre code.language-mermaid",
      "code.language-mermaid",
      'pre[class*="language-mermaid"]',
      'code[class*="language-mermaid"]',
      "pre:has(code.language-mermaid)",
      ".astro-code.language-mermaid",
    ];

    let mermaidElements = [];
    selectors.forEach((selector) => {
      try {
        const elements = document.querySelectorAll(selector);
        mermaidElements = [...mermaidElements, ...elements];
      } catch (e) {
        // Skip selectors that aren't supported
      }
    });

    // Also check for any pre elements containing Mermaid diagram keywords
    const preElements = document.querySelectorAll("pre");
    preElements.forEach((pre) => {
      const text = pre.textContent || pre.innerText;
      // Check for common Mermaid diagram types
      const mermaidKeywords = [
        "graph TB",
        "graph TD",
        "graph LR",
        "graph RL",
        "flowchart",
        "sequenceDiagram",
        "classDiagram",
        "stateDiagram",
        "erDiagram",
        "gantt",
        "pie title",
        "pie ",
        "journey",
        "gitGraph",
        "C4Context",
        "mindmap",
        "timeline",
      ];

      if (mermaidKeywords.some((keyword) => text.includes(keyword))) {
        mermaidElements.push(pre);
      }
    });

    console.log("Found mermaid elements:", mermaidElements.length);

    mermaidElements.forEach((element, index) => {
      // Skip if already processed
      if (element.classList.contains("mermaid-processed")) return;

      const mermaidCode = element.textContent || element.innerText;
      console.log(
        "Processing mermaid code:",
        mermaidCode.substring(0, 50) + "...",
      );

      const mermaidId = `mermaid-${index}-${Date.now()}`;

      // Create a div to hold the rendered diagram
      const mermaidDiv = document.createElement("div");
      mermaidDiv.id = mermaidId;
      mermaidDiv.className = "mermaid";
      mermaidDiv.textContent = mermaidCode.trim();

      // Replace the code block with the mermaid div
      const parent = element.closest("pre") || element;
      parent.parentNode.replaceChild(mermaidDiv, parent);

      // Mark as processed
      mermaidDiv.classList.add("mermaid-processed");
    });

    // Re-run mermaid on the new elements and setup click handlers
    if (mermaidElements.length > 0) {
      mermaid.run().then(() => {
        setupMermaidClickHandlers();
      });
    } else {
      setupMermaidClickHandlers();
    }
  }

  // Create and setup the mermaid modal
  function createMermaidModal() {
    // Check if modal already exists
    if (document.getElementById("mermaid-modal")) {
      return document.getElementById("mermaid-modal");
    }

    // Lucide icons as SVG strings
    const icons = {
      zoomIn: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" x2="16.65" y1="21" y2="16.65"/><line x1="11" x2="11" y1="8" y2="14"/><line x1="8" x2="14" y1="11" y2="11"/></svg>`,
      zoomOut: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" x2="16.65" y1="21" y2="16.65"/><line x1="8" x2="14" y1="11" y2="11"/></svg>`,
      reset: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>`,
      close: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>`,
    };

    const modal = document.createElement("div");
    modal.id = "mermaid-modal";
    modal.className = "mermaid-modal-overlay";
    modal.innerHTML = `
      <div class="mermaid-modal-content">
        <div class="mermaid-modal-controls">
          <button class="mermaid-modal-btn" id="mermaid-zoom-out" title="Zoom Out">${icons.zoomOut}</button>
          <span class="mermaid-modal-zoom-info" id="mermaid-zoom-level">100%</span>
          <button class="mermaid-modal-btn" id="mermaid-zoom-in" title="Zoom In">${icons.zoomIn}</button>
          <div class="mermaid-modal-divider"></div>
          <button class="mermaid-modal-btn" id="mermaid-zoom-reset" title="Reset">${icons.reset}</button>
          <button class="mermaid-modal-btn" id="mermaid-close" title="Close">${icons.close}</button>
        </div>
        <div class="mermaid-modal-diagram" id="mermaid-diagram-container"></div>
        <div class="mermaid-modal-hint">Scroll to zoom • Drag to pan</div>
      </div>
    `;

    document.body.appendChild(modal);

    // Setup modal controls
    let currentZoom = 1;
    let isPanning = false;
    let startX = 0,
      startY = 0;
    let scrollLeft = 0,
      scrollTop = 0;

    const container = modal.querySelector("#mermaid-diagram-container");
    const zoomLevelDisplay = modal.querySelector("#mermaid-zoom-level");

    function updateZoom(centerAfterZoom = true) {
      const wrapper = container.querySelector(".mermaid-svg-wrapper");
      const svg = container.querySelector("svg");
      if (svg && wrapper) {
        // Get original dimensions from stored data (set when modal opens)
        const originalWidth =
          parseFloat(container.dataset.originalWidth) ||
          svg.getBoundingClientRect().width;
        const originalHeight =
          parseFloat(container.dataset.originalHeight) ||
          svg.getBoundingClientRect().height;

        // Calculate scaled dimensions
        const scaledWidth = originalWidth * currentZoom;
        const scaledHeight = originalHeight * currentZoom;

        // Apply scale transform
        svg.style.transform = `scale(${currentZoom})`;
        svg.style.transformOrigin = "top left";
        zoomLevelDisplay.textContent = `${Math.round(currentZoom * 100)}%`;

        // Get container dimensions
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;

        // Calculate padding to center the content
        // When content is smaller than container, padding centers it
        // When content is larger, padding allows scrolling to all edges
        const paddingX = Math.max(containerWidth / 2, scaledWidth / 2);
        const paddingY = Math.max(containerHeight / 2, scaledHeight / 2);

        // Set wrapper size and padding for centering
        wrapper.style.width = `${scaledWidth}px`;
        wrapper.style.height = `${scaledHeight}px`;
        wrapper.style.margin = `${paddingY}px ${paddingX}px`;

        // Center the scroll position after zoom
        if (centerAfterZoom) {
          requestAnimationFrame(() => {
            // Scroll to center the content
            const totalWidth = scaledWidth + paddingX * 2;
            const totalHeight = scaledHeight + paddingY * 2;

            container.scrollLeft = (totalWidth - containerWidth) / 2;
            container.scrollTop = (totalHeight - containerHeight) / 2;
          });
        }
      }
    }

    function zoomIn() {
      currentZoom = Math.min(currentZoom * 1.25, 5);
      updateZoom(true);
    }

    function zoomOut() {
      currentZoom = Math.max(currentZoom * 0.8, 0.25);
      updateZoom(true);
    }

    function resetZoom() {
      currentZoom = 1;
      const wrapper = container.querySelector(".mermaid-svg-wrapper");
      if (wrapper) {
        wrapper.style.width = "";
        wrapper.style.height = "";
        wrapper.style.margin = "";
      }
      updateZoom(true);
    }

    function closeModal() {
      modal.classList.remove("active");
      document.body.style.overflow = "";
      currentZoom = 1;

      // Remove hash from URL if it's #mermaid-preview
      if (window.location.hash === "#mermaid-preview") {
        history.back();
      }
    }

    // Button handlers
    modal.querySelector("#mermaid-zoom-in").addEventListener("click", zoomIn);
    modal.querySelector("#mermaid-zoom-out").addEventListener("click", zoomOut);
    modal
      .querySelector("#mermaid-zoom-reset")
      .addEventListener("click", resetZoom);
    modal.querySelector("#mermaid-close").addEventListener("click", closeModal);

    // Close on overlay click
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        closeModal();
      }
    });

    // Close on Escape key
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && modal.classList.contains("active")) {
        closeModal();
      }
    });

    // Mouse wheel zoom
    container.addEventListener(
      "wheel",
      (e) => {
        e.preventDefault();
        if (e.deltaY < 0) {
          zoomIn();
        } else {
          zoomOut();
        }
      },
      { passive: false },
    );

    // Pan functionality (mouse)
    container.addEventListener("mousedown", (e) => {
      e.preventDefault(); // Prevent default drag behavior
      isPanning = true;
      container.style.cursor = "grabbing";
      startX = e.pageX - container.offsetLeft;
      startY = e.pageY - container.offsetTop;
      scrollLeft = container.scrollLeft;
      scrollTop = container.scrollTop;
    });

    container.addEventListener("mousemove", (e) => {
      if (!isPanning) return;
      e.preventDefault();
      const x = e.pageX - container.offsetLeft;
      const y = e.pageY - container.offsetTop;
      const walkX = (x - startX) * 1.5;
      const walkY = (y - startY) * 1.5;
      container.scrollLeft = scrollLeft - walkX;
      container.scrollTop = scrollTop - walkY;
    });

    container.addEventListener("mouseup", () => {
      isPanning = false;
      container.style.cursor = "grab";
    });

    container.addEventListener("mouseleave", () => {
      isPanning = false;
      container.style.cursor = "grab";
    });

    // Touch support for mobile
    let initialDistance = 0;
    let lastTouchX = 0,
      lastTouchY = 0;

    container.addEventListener(
      "touchstart",
      (e) => {
        if (e.touches.length === 2) {
          // Pinch zoom start
          initialDistance = Math.hypot(
            e.touches[0].pageX - e.touches[1].pageX,
            e.touches[0].pageY - e.touches[1].pageY,
          );
        } else if (e.touches.length === 1) {
          // Pan start
          isPanning = true;
          lastTouchX = e.touches[0].pageX;
          lastTouchY = e.touches[0].pageY;
          scrollLeft = container.scrollLeft;
          scrollTop = container.scrollTop;
        }
      },
      { passive: false },
    );

    container.addEventListener(
      "touchmove",
      (e) => {
        e.preventDefault();
        if (e.touches.length === 2) {
          // Pinch zoom
          const newDistance = Math.hypot(
            e.touches[0].pageX - e.touches[1].pageX,
            e.touches[0].pageY - e.touches[1].pageY,
          );
          const delta = newDistance - initialDistance;
          if (Math.abs(delta) > 10) {
            if (delta > 0) {
              currentZoom = Math.min(currentZoom * 1.05, 5);
            } else {
              currentZoom = Math.max(currentZoom * 0.95, 0.25);
            }
            updateZoom();
            initialDistance = newDistance;
          }
        } else if (e.touches.length === 1 && isPanning) {
          // Pan
          const touchX = e.touches[0].pageX;
          const touchY = e.touches[0].pageY;
          const walkX = touchX - lastTouchX;
          const walkY = touchY - lastTouchY;
          container.scrollLeft = scrollLeft - walkX;
          container.scrollTop = scrollTop - walkY;
        }
      },
      { passive: false },
    );

    container.addEventListener("touchend", () => {
      isPanning = false;
      initialDistance = 0;
    });

    // Store functions on modal for external access
    modal._updateZoom = updateZoom;
    modal._setZoom = (zoom) => {
      currentZoom = zoom;
    };
    modal._resetZoom = () => {
      currentZoom = 1;
    };

    return modal;
  }

  // Open a diagram in the modal
  function openMermaidModal(diagramElement) {
    const modal = createMermaidModal();
    const container = modal.querySelector("#mermaid-diagram-container");
    const svg = diagramElement.querySelector("svg");

    if (svg) {
      // Get original dimensions before cloning
      const originalRect = svg.getBoundingClientRect();

      // Clone the SVG and put it in the modal with a wrapper
      const clonedSvg = svg.cloneNode(true);
      clonedSvg.style.transform = "scale(1)";
      clonedSvg.style.transformOrigin = "top left";

      // Create wrapper for proper pan/zoom behavior
      const wrapper = document.createElement("div");
      wrapper.className = "mermaid-svg-wrapper";
      wrapper.appendChild(clonedSvg);

      container.innerHTML = "";
      container.appendChild(wrapper);

      // Store original dimensions for zoom calculations
      container.dataset.originalWidth = originalRect.width;
      container.dataset.originalHeight = originalRect.height;

      // Calculate initial zoom to fit screen
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const padding = 40; // 20px padding on each side

      const fitWidth = (viewportWidth - padding) / originalRect.width;
      const fitHeight = (viewportHeight - padding) / originalRect.height;

      // Use the smaller scale factor, but don't zoom in (max 1.0)
      const initialZoom = Math.min(1, fitWidth, fitHeight);

      // Set initial zoom
      modal._setZoom(initialZoom);
      modal.querySelector("#mermaid-zoom-level").textContent =
        `${Math.round(initialZoom * 100)}%`;

      // Add hash to URL for browser back button support
      history.pushState(null, "", "#mermaid-preview");

      // Show modal
      modal.classList.add("active");
      document.body.style.overflow = "hidden";

      // Center the content after modal is visible
      requestAnimationFrame(() => {
        modal._updateZoom(true);
      });
    }
  }

  // Listen for browser back button to close mermaid modal
  window.addEventListener("popstate", () => {
    const modal = document.getElementById("mermaid-modal");
    if (
      modal &&
      modal.classList.contains("active") &&
      window.location.hash !== "#mermaid-preview"
    ) {
      modal.classList.remove("active");
      document.body.style.overflow = "";
    }
  });

  // Setup click handlers for all mermaid diagrams
  function setupMermaidClickHandlers() {
    const diagrams = document.querySelectorAll(".mermaid");
    diagrams.forEach((diagram) => {
      // Skip if already has click handler
      if (diagram.dataset.hasClickHandler) return;

      diagram.dataset.hasClickHandler = "true";
      diagram.style.cursor = "pointer";
      diagram.title = "Click to expand diagram";

      diagram.addEventListener("click", () => {
        openMermaidModal(diagram);
      });
    });
  }

  // Function to update Mermaid theme and re-render diagrams
  function updateMermaidTheme() {
    const currentTheme = getCurrentTheme();
    const newThemeVariables = getMermaidThemeVariables(currentTheme);

    // Update Mermaid configuration with new theme variables
    mermaid.initialize({
      startOnLoad: false,
      theme: "default",
      themeVariables: newThemeVariables,
      gantt: {
        titleTopMargin: 25,
        barHeight: 30,
        barGap: 4,
        topPadding: 50,
        leftPadding: 75,
        gridLineStartPadding: 35,
        fontSize: 12,
        numberSectionStyles: 4,
        axisFormat: "%b '%y",
        useMaxWidth: true,
      },
    });

    // Re-render all existing Mermaid diagrams with new theme
    const existingMermaidDiagrams = document.querySelectorAll(".mermaid");
    if (existingMermaidDiagrams.length > 0) {
      mermaid.run();
    }
  }

  // Function to handle theme changes
  function handleThemeChange() {
    updateMermaidTheme();
  }

  // Listen for theme changes
  const themeObserver = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (
        mutation.type === "attributes" &&
        mutation.attributeName === "class"
      ) {
        const target = mutation.target;
        if (target === document.documentElement) {
          handleThemeChange();
        }
      }
    });
  });

  // Start observing theme changes
  themeObserver.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ["class"],
  });

  // Render on initial load
  document.addEventListener("DOMContentLoaded", () => {
    renderMermaidDiagrams();
    wrapWideTables();
  });

  // Render on Astro page transitions
  document.addEventListener("astro:page-load", () => {
    renderMermaidDiagrams();
    wrapWideTables();
  });

  // Function to wrap wide tables in scrollable containers
  function wrapWideTables() {
    const tables = document.querySelectorAll("table");

    tables.forEach((table, index) => {
      // Skip if already wrapped
      if (table.parentElement.classList.contains("table-scroll-container")) {
        return;
      }

      // Check if table is wider than its container
      const tableRect = table.getBoundingClientRect();
      const containerRect = table.parentElement.getBoundingClientRect();

      // If table is wider than container or if we're on mobile, wrap it
      const isOnMobile = window.innerWidth <= 768;
      const isTableTooWide = tableRect.width > containerRect.width;

      if (isTableTooWide || isOnMobile) {
        // Create scrollable container
        const scrollContainer = document.createElement("div");
        scrollContainer.className = "table-scroll-container";

        // Insert container before table
        table.parentElement.insertBefore(scrollContainer, table);

        // Move table into container
        scrollContainer.appendChild(table);

        console.log(`Wrapped table ${index + 1} in scrollable container`);
      }
    });
  }

  // Re-wrap tables on window resize
  let resizeTimeout;
  window.addEventListener("resize", () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      wrapWideTables();
    }, 250); // Debounce resize events
  });

  // ===== Image Modal Preview =====

  // Create and setup the image modal
  function createImageModal() {
    // Check if modal already exists
    if (document.getElementById("image-modal")) {
      return document.getElementById("image-modal");
    }

    // Lucide icons as SVG strings
    const icons = {
      zoomIn: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" x2="16.65" y1="21" y2="16.65"/><line x1="11" x2="11" y1="8" y2="14"/><line x1="8" x2="14" y1="11" y2="11"/></svg>`,
      zoomOut: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" x2="16.65" y1="21" y2="16.65"/><line x1="8" x2="14" y1="11" y2="11"/></svg>`,
      reset: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>`,
      close: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>`,
    };

    const modal = document.createElement("div");
    modal.id = "image-modal";
    modal.className = "image-modal-overlay";
    modal.innerHTML = `
      <div class="image-modal-content">
        <div class="image-modal-controls">
          <button class="image-modal-btn" id="image-zoom-out" title="Zoom Out">${icons.zoomOut}</button>
          <span class="image-modal-zoom-info" id="image-zoom-level">100%</span>
          <button class="image-modal-btn" id="image-zoom-in" title="Zoom In">${icons.zoomIn}</button>
          <div class="image-modal-divider"></div>
          <button class="image-modal-btn" id="image-zoom-reset" title="Reset">${icons.reset}</button>
          <button class="image-modal-btn" id="image-close" title="Close">${icons.close}</button>
        </div>
        <div class="image-modal-container" id="image-modal-container"></div>
        <div class="image-modal-hint">Scroll to zoom • Drag to pan</div>
      </div>
    `;

    document.body.appendChild(modal);

    // Setup modal controls
    let currentZoom = 1;
    let isPanning = false;
    let startX = 0,
      startY = 0;
    let scrollLeft = 0,
      scrollTop = 0;

    const container = modal.querySelector("#image-modal-container");
    const zoomLevelDisplay = modal.querySelector("#image-zoom-level");

    function updateZoom(centerAfterZoom = true) {
      const wrapper = container.querySelector(".image-wrapper");
      const img = container.querySelector("img");
      if (img && wrapper) {
        // Get original dimensions from stored data (set when modal opens)
        const originalWidth =
          parseFloat(container.dataset.originalWidth) ||
          img.getBoundingClientRect().width;
        const originalHeight =
          parseFloat(container.dataset.originalHeight) ||
          img.getBoundingClientRect().height;

        // Calculate scaled dimensions
        const scaledWidth = originalWidth * currentZoom;
        const scaledHeight = originalHeight * currentZoom;

        // Apply scale transform
        img.style.transform = `scale(${currentZoom})`;
        img.style.transformOrigin = "top left";
        zoomLevelDisplay.textContent = `${Math.round(currentZoom * 100)}%`;

        // Set wrapper size to scaled dimensions
        wrapper.style.width = `${scaledWidth}px`;
        wrapper.style.height = `${scaledHeight}px`;

        // Use margin: auto for robust centering (centers when small, top-left aligns when overflowing)
        wrapper.style.margin = "auto";

        // Ensure container handles scrolling
        if (centerAfterZoom) {
          // With margin: auto, we just need to ensure we don't hold onto old scroll positions unexpectedly
          // forcing a scroll to roughly center might be needed only if we zoomed in significantly,
          // but margin: auto handles the placement. Resetting scroll might be safer for "fit" zoom.
          if (currentZoom <= 1.0) {
            container.scrollLeft = 0;
            container.scrollTop = 0;
          }
        }
      }
    }

    function zoomIn() {
      currentZoom = Math.min(currentZoom * 1.25, 5);
      updateZoom(true);
    }

    function zoomOut() {
      currentZoom = Math.max(currentZoom * 0.8, 0.25);
      updateZoom(true);
    }

    function resetZoom() {
      currentZoom = 1;
      const wrapper = container.querySelector(".image-wrapper");
      if (wrapper) {
        wrapper.style.width = "";
        wrapper.style.height = "";
        wrapper.style.margin = "";
      }
      updateZoom(true);
    }

    function closeModal() {
      modal.classList.remove("active");
      document.body.style.overflow = "";
      currentZoom = 1;

      // Remove hash from URL if it's #image-preview
      if (window.location.hash === "#image-preview") {
        history.back();
      }
    }

    // Button handlers
    modal.querySelector("#image-zoom-in").addEventListener("click", zoomIn);
    modal.querySelector("#image-zoom-out").addEventListener("click", zoomOut);
    modal
      .querySelector("#image-zoom-reset")
      .addEventListener("click", resetZoom);
    modal.querySelector("#image-close").addEventListener("click", closeModal);

    // Close on overlay click
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        closeModal();
      }
    });

    // Close on Escape key
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && modal.classList.contains("active")) {
        closeModal();
      }
    });

    // Mouse wheel zoom
    container.addEventListener(
      "wheel",
      (e) => {
        e.preventDefault();
        if (e.deltaY < 0) {
          zoomIn();
        } else {
          zoomOut();
        }
      },
      { passive: false },
    );

    // Pan functionality (mouse)
    container.addEventListener("mousedown", (e) => {
      e.preventDefault(); // Prevent default drag behavior
      isPanning = true;
      container.style.cursor = "grabbing";
      startX = e.pageX - container.offsetLeft;
      startY = e.pageY - container.offsetTop;
      scrollLeft = container.scrollLeft;
      scrollTop = container.scrollTop;
    });

    container.addEventListener("mousemove", (e) => {
      if (!isPanning) return;
      e.preventDefault();
      const x = e.pageX - container.offsetLeft;
      const y = e.pageY - container.offsetTop;
      const walkX = (x - startX) * 1.5;
      const walkY = (y - startY) * 1.5;
      container.scrollLeft = scrollLeft - walkX;
      container.scrollTop = scrollTop - walkY;
    });

    container.addEventListener("mouseup", () => {
      isPanning = false;
      container.style.cursor = "grab";
    });

    container.addEventListener("mouseleave", () => {
      isPanning = false;
      container.style.cursor = "grab";
    });

    // Touch support for mobile
    let initialDistance = 0;
    let lastTouchX = 0,
      lastTouchY = 0;

    container.addEventListener(
      "touchstart",
      (e) => {
        if (e.touches.length === 2) {
          // Pinch zoom start
          initialDistance = Math.hypot(
            e.touches[0].pageX - e.touches[1].pageX,
            e.touches[0].pageY - e.touches[1].pageY,
          );
        } else if (e.touches.length === 1) {
          // Pan start
          isPanning = true;
          lastTouchX = e.touches[0].pageX;
          lastTouchY = e.touches[0].pageY;
          scrollLeft = container.scrollLeft;
          scrollTop = container.scrollTop;
        }
      },
      { passive: false },
    );

    container.addEventListener(
      "touchmove",
      (e) => {
        e.preventDefault();
        if (e.touches.length === 2) {
          // Pinch zoom
          const newDistance = Math.hypot(
            e.touches[0].pageX - e.touches[1].pageX,
            e.touches[0].pageY - e.touches[1].pageY,
          );
          const delta = newDistance - initialDistance;
          if (Math.abs(delta) > 10) {
            if (delta > 0) {
              currentZoom = Math.min(currentZoom * 1.05, 5);
            } else {
              currentZoom = Math.max(currentZoom * 0.95, 0.25);
            }
            updateZoom();
            initialDistance = newDistance;
          }
        } else if (e.touches.length === 1 && isPanning) {
          // Pan
          const touchX = e.touches[0].pageX;
          const touchY = e.touches[0].pageY;
          const walkX = touchX - lastTouchX;
          const walkY = touchY - lastTouchY;
          container.scrollLeft = scrollLeft - walkX;
          container.scrollTop = scrollTop - walkY;
        }
      },
      { passive: false },
    );

    container.addEventListener("touchend", () => {
      isPanning = false;
      initialDistance = 0;
    });

    // Store functions on modal for external access
    modal._updateZoom = updateZoom;
    modal._setZoom = (zoom) => {
      currentZoom = zoom;
    };
    modal._resetZoom = () => {
      currentZoom = 1;
    };

    return modal;
  }

  // Open an image in the modal
  function openImageModal(imgElement) {
    const modal = createImageModal();
    const container = modal.querySelector("#image-modal-container");

    // Get original dimensions before cloning
    const originalRect = imgElement.getBoundingClientRect();

    // Clone the image and put it in the modal with a wrapper
    const clonedImg = imgElement.cloneNode(true);
    clonedImg.style.transform = "scale(1)";
    clonedImg.style.transformOrigin = "top left";
    clonedImg.removeAttribute("class"); // Remove any classes that might interfere
    clonedImg.classList.add("image-modal-img");

    // Create wrapper for proper pan/zoom behavior
    const wrapper = document.createElement("div");
    wrapper.className = "image-wrapper";
    wrapper.appendChild(clonedImg);

    container.innerHTML = "";
    container.appendChild(wrapper);

    // For images, we can use natural dimensions if available, or the client rect
    // Ensure we use the best available dimension source
    const contentWidth = imgElement.naturalWidth || originalRect.width;
    const contentHeight = imgElement.naturalHeight || originalRect.height;

    // Explicitly set the clone's dimensions to match what we use for calculation
    clonedImg.style.width = `${contentWidth}px`;
    clonedImg.style.height = `${contentHeight}px`;

    // Store TRUE dimensions for zoom calculations
    container.dataset.originalWidth = contentWidth;
    container.dataset.originalHeight = contentHeight;

    // Calculate initial zoom to fit screen
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    // Padding must match CSS: 2rem horizontal (32px), 5rem vertical (80px)
    const paddingX = 40;
    const paddingY = 90; // 2.5rem top + 2.5rem bottom + buffer

    const fitWidth = (viewportWidth - paddingX) / contentWidth;
    const fitHeight = (viewportHeight - paddingY) / contentHeight;

    // Use the smaller scale factor, but don't zoom in (max 1.0)
    const initialZoom = Math.min(1, fitWidth, fitHeight);

    // Set initial zoom
    modal._setZoom(initialZoom);
    modal.querySelector("#image-zoom-level").textContent =
      `${Math.round(initialZoom * 100)}%`;

    // Add hash to URL for browser back button support
    history.pushState(null, "", "#image-preview");

    // Show modal
    modal.classList.add("active");
    document.body.style.overflow = "hidden";

    // Center the content after modal is visible
    requestAnimationFrame(() => {
      modal._updateZoom(true);
    });
  }

  // Listen for browser back button to close image modal
  window.addEventListener("popstate", () => {
    const modal = document.getElementById("image-modal");
    if (
      modal &&
      modal.classList.contains("active") &&
      window.location.hash !== "#image-preview"
    ) {
      modal.classList.remove("active");
      document.body.style.overflow = "";
    }
  });

  // Setup click handlers for images in content areas
  function setupImageClickHandlers() {
    // Select images within .content areas (blog posts)
    const images = document.querySelectorAll(".content img");

    images.forEach((img) => {
      // Skip if already has click handler
      if (img.dataset.hasModalHandler) return;

      // Skip small images (likely icons) and images inside links
      if (img.closest("a")) return;

      img.dataset.hasModalHandler = "true";
      img.style.cursor = "pointer";
      img.title = "Click to expand image";
      img.classList.add("image-expandable");

      img.addEventListener("click", (e) => {
        e.preventDefault();
        openImageModal(img);
      });
    });
  }

  // Initialize image modal handlers
  document.addEventListener("DOMContentLoaded", () => {
    setupImageClickHandlers();
  });

  // Setup on Astro page transitions
  document.addEventListener("astro:page-load", () => {
    setupImageClickHandlers();
  });
</script>
