---
import { ViewTransitions } from "astro:transitions";
import "../styles/fonts.css";
import "../styles/global.css";

export interface Props {
  title: string;
  description: string;
  permalink: string;
  image?: string;
  type?: "website" | "article";
  publishDate?: string;
}

const {
  title,
  description,
  permalink,
  image,
  type = "website",
  publishDate,
} = Astro.props;

// Ensure the permalink is absolute
const canonicalURL = new URL(permalink, Astro.site).href;
// Use provided image or fallback to default social image
const socialImageURL = image
  ? new URL(image, Astro.site).href
  : new URL("assets/social.png", Astro.site).href;
---

<!-- Global Metadata -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width" />
<link rel="icon" type="image/x-icon" href="/favicon.ico" />
<link rel="canonical" href={canonicalURL} />
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;600;700&family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap"
  rel="stylesheet"
/>

<!-- Primary Meta Tags -->
<title>{title}</title>
<meta name="title" content={title} />
<meta name="description" content={description} />
{publishDate && <meta name="date" content={publishDate} />}

<!-- Open Graph / Facebook -->
<meta property="og:type" content={type} />
<meta property="og:url" content={canonicalURL} />
<meta property="og:title" content={title} />
<meta property="og:description" content={description} />
<meta property="og:image" content={socialImageURL} />
{
  publishDate && (
    <meta
      property="article:published_time"
      content={new Date(publishDate).toISOString()}
    />
  )
}

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image" />
<meta property="twitter:url" content={canonicalURL} />
<meta property="twitter:title" content={title} />
<meta property="twitter:description" content={description} />
<meta property="twitter:image" content={socialImageURL} />

<ViewTransitions />

<!-- This is intentionally inlined to avoid FOUC -->
<script is:inline>
  const root = document.documentElement;
  const theme = localStorage.getItem("theme");
  if (
    theme === "dark" ||
    (!theme && window.matchMedia("(prefers-color-scheme: dark)").matches)
  ) {
    root.classList.add("theme-dark");
  } else {
    root.classList.remove("theme-dark");
  }
</script>

<!-- Twitter Widget Script -->
<script is:inline>
  window.twttr = (function (d, s, id) {
    var js,
      fjs = d.getElementsByTagName(s)[0],
      t = window.twttr || {};
    if (d.getElementById(id)) return t;
    js = d.createElement(s);
    js.id = id;
    js.src = "https://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js, fjs);

    t._e = [];
    t.ready = function (f) {
      t._e.push(f);
    };

    return t;
  })(document, "script", "twitter-wjs");

  // Function to load Twitter widgets
  function loadTwitterWidgets() {
    if (window.twttr && window.twttr.widgets) {
      window.twttr.widgets.load();
    }
  }

  // Load on initial page load
  document.addEventListener("DOMContentLoaded", loadTwitterWidgets);

  // Load on Astro page transitions
  document.addEventListener("astro:page-load", loadTwitterWidgets);

  // Load when Twitter script is ready
  window.twttr.ready(loadTwitterWidgets);
</script>

<!-- Mermaid Script -->
<script type="module">
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  // Function to get current theme
  function getCurrentTheme() {
    return document.documentElement.classList.contains('theme-dark') ? 'dark' : 'light';
  }

  // Function to get Mermaid theme variables based on current theme
  function getMermaidThemeVariables(theme) {
    if (theme === 'dark') {
      return {
        primaryColor: "#ff6b6b",
        primaryTextColor: "#f4f4f5",
        primaryBorderColor: "#ff6b6b",
        lineColor: "#a1a1aa",
        secondaryColor: "#18181b",
        tertiaryColor: "#09090b",
        background: "#09090b",
        mainBkg: "#18181b",
        secondBkg: "#27272a",
        tertiaryBkg: "#3f3f46",
        // Text colors for dark mode
        textColor: "#f4f4f5",
        nodeTextColor: "#f4f4f5",
        nodeLabelColor: "#f4f4f5",
        nodeLabelBackgroundColor: "#18181b",
        // Grid and border colors
        gridColor: "#3f3f46",
        border1: "#3f3f46",
        border2: "#52525b",
        // Section colors
        altSectionBkg: "#18181b",
        // Pie chart colors
        pieTitleTextColor: "#f4f4f5",
        pieOuterStrokeColor: "#f4f4f4",
        pieSectionTextColor: "#f4f4f4",
        pieOuterStrokeWidth: "2px",
      };
    } else {
      return {
        primaryColor: "#ff6b6b",
        primaryTextColor: "#333",
        primaryBorderColor: "#ff6b6b",
        lineColor: "#666",
        secondaryColor: "#f9f9f9",
        tertiaryColor: "#fff",
        background: "#ffffff",
        mainBkg: "#ffffff",
        secondBkg: "#f9f9f9",
        tertiaryBkg: "#f0f0f0",
        // Text colors for light mode
        textColor: "#333",
        nodeTextColor: "#333",
        nodeLabelColor: "#333",
        nodeLabelBackgroundColor: "#ffffff",
        // Grid and border colors
        gridColor: "#cccccc",
        border1: "#cccccc",
        border2: "#999999",
        // Section colors
        altSectionBkg: "#f9f9f9",
        // Pie chart colors
        pieTitleTextColor: "#333",
        pieOuterStrokeColor: "#333333",
        pieSectionTextColor: "#333333",
        pieOuterStrokeWidth: "2px",
      };
    }
  }

  // Initialize Mermaid with theme detection
  function initializeMermaid() {
    const currentTheme = getCurrentTheme();
    mermaid.initialize({
      startOnLoad: true,
      theme: "default",
      themeVariables: getMermaidThemeVariables(currentTheme),
      gantt: {
        titleTopMargin: 25,
        barHeight: 30,
        barGap: 4,
        topPadding: 50,
        leftPadding: 75,
        gridLineStartPadding: 35,
        fontSize: 12,
        numberSectionStyles: 4,
        axisFormat: "%b '%y", // Compact format: Jan '24, Feb '24, etc.
        useMaxWidth: true,
      },
    });
  }

  // Initialize on load
  initializeMermaid();

  // Function to render Mermaid diagrams
  function renderMermaidDiagrams() {
    // Try multiple selectors to catch different MDX rendering patterns
    const selectors = [
      "pre code.language-mermaid",
      "code.language-mermaid",
      'pre[class*="language-mermaid"]',
      'code[class*="language-mermaid"]',
      "pre:has(code.language-mermaid)",
      ".astro-code.language-mermaid",
    ];

    let mermaidElements = [];
    selectors.forEach((selector) => {
      try {
        const elements = document.querySelectorAll(selector);
        mermaidElements = [...mermaidElements, ...elements];
      } catch (e) {
        // Skip selectors that aren't supported
      }
    });

    // Also check for any pre elements containing Mermaid diagram keywords
    const preElements = document.querySelectorAll("pre");
    preElements.forEach((pre) => {
      const text = pre.textContent || pre.innerText;
      // Check for common Mermaid diagram types
      const mermaidKeywords = [
        "graph TB",
        "graph TD",
        "graph LR",
        "graph RL",
        "flowchart",
        "sequenceDiagram",
        "classDiagram",
        "stateDiagram",
        "erDiagram",
        "gantt",
        "pie title",
        "pie ",
        "journey",
        "gitGraph",
        "C4Context",
        "mindmap",
        "timeline",
      ];

      if (mermaidKeywords.some((keyword) => text.includes(keyword))) {
        mermaidElements.push(pre);
      }
    });

    console.log("Found mermaid elements:", mermaidElements.length);

    mermaidElements.forEach((element, index) => {
      // Skip if already processed
      if (element.classList.contains("mermaid-processed")) return;

      const mermaidCode = element.textContent || element.innerText;
      console.log(
        "Processing mermaid code:",
        mermaidCode.substring(0, 50) + "...",
      );

      const mermaidId = `mermaid-${index}-${Date.now()}`;

      // Create a div to hold the rendered diagram
      const mermaidDiv = document.createElement("div");
      mermaidDiv.id = mermaidId;
      mermaidDiv.className = "mermaid";
      mermaidDiv.textContent = mermaidCode.trim();

      // Replace the code block with the mermaid div
      const parent = element.closest("pre") || element;
      parent.parentNode.replaceChild(mermaidDiv, parent);

      // Mark as processed
      mermaidDiv.classList.add("mermaid-processed");
    });

    // Re-run mermaid on the new elements
    if (mermaidElements.length > 0) {
      mermaid.run();
    }
  }

  // Function to update Mermaid theme and re-render diagrams
  function updateMermaidTheme() {
    const currentTheme = getCurrentTheme();
    const newThemeVariables = getMermaidThemeVariables(currentTheme);
    
    // Update Mermaid configuration with new theme variables
    mermaid.initialize({
      startOnLoad: false,
      theme: "default",
      themeVariables: newThemeVariables,
      gantt: {
        titleTopMargin: 25,
        barHeight: 30,
        barGap: 4,
        topPadding: 50,
        leftPadding: 75,
        gridLineStartPadding: 35,
        fontSize: 12,
        numberSectionStyles: 4,
        axisFormat: "%b '%y",
        useMaxWidth: true,
      },
    });

    // Re-render all existing Mermaid diagrams with new theme
    const existingMermaidDiagrams = document.querySelectorAll('.mermaid');
    if (existingMermaidDiagrams.length > 0) {
      mermaid.run();
    }
  }

  // Function to handle theme changes
  function handleThemeChange() {
    updateMermaidTheme();
  }

  // Listen for theme changes
  const themeObserver = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
        const target = mutation.target;
        if (target === document.documentElement) {
          handleThemeChange();
        }
      }
    });
  });

  // Start observing theme changes
  themeObserver.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ['class']
  });

  // Render on initial load
  document.addEventListener("DOMContentLoaded", () => {
    renderMermaidDiagrams();
    wrapWideTables();
  });

  // Render on Astro page transitions
  document.addEventListener("astro:page-load", () => {
    renderMermaidDiagrams();
    wrapWideTables();
  });

  // Function to wrap wide tables in scrollable containers
  function wrapWideTables() {
    const tables = document.querySelectorAll('table');
    
    tables.forEach((table, index) => {
      // Skip if already wrapped
      if (table.parentElement.classList.contains('table-scroll-container')) {
        return;
      }
      
      // Check if table is wider than its container
      const tableRect = table.getBoundingClientRect();
      const containerRect = table.parentElement.getBoundingClientRect();
      
      // If table is wider than container or if we're on mobile, wrap it
      const isOnMobile = window.innerWidth <= 768;
      const isTableTooWide = tableRect.width > containerRect.width;
      
      if (isTableTooWide || isOnMobile) {
        // Create scrollable container
        const scrollContainer = document.createElement('div');
        scrollContainer.className = 'table-scroll-container';
        
        // Insert container before table
        table.parentElement.insertBefore(scrollContainer, table);
        
        // Move table into container
        scrollContainer.appendChild(table);
        
        console.log(`Wrapped table ${index + 1} in scrollable container`);
      }
    });
  }

  // Re-wrap tables on window resize
  let resizeTimeout;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      wrapWideTables();
    }, 250); // Debounce resize events
  });
</script>
