---
import { ViewTransitions } from "astro:transitions";
import "../styles/fonts.css";
import "../styles/global.css";

export interface Props {
  title: string;
  description: string;
  permalink: string;
  image?: string;
  type?: "website" | "article";
  publishDate?: string;
}

const {
  title,
  description,
  permalink,
  image,
  type = "website",
  publishDate,
} = Astro.props;

// Ensure the permalink is absolute
const canonicalURL = new URL(permalink, Astro.site).href;
// Use provided image or fallback to default social image
const socialImageURL = image
  ? new URL(image, Astro.site).href
  : new URL("assets/social.png", Astro.site).href;
---

<!-- Global Metadata -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width" />
<link rel="icon" type="image/x-icon" href="/favicon.ico" />
<link rel="canonical" href={canonicalURL} />
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;600;700&family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap"
  rel="stylesheet"
/>

<!-- Primary Meta Tags -->
<title>{title}</title>
<meta name="title" content={title} />
<meta name="description" content={description} />
{publishDate && <meta name="date" content={publishDate} />}

<!-- Open Graph / Facebook -->
<meta property="og:type" content={type} />
<meta property="og:url" content={canonicalURL} />
<meta property="og:title" content={title} />
<meta property="og:description" content={description} />
<meta property="og:image" content={socialImageURL} />
{
  publishDate && (
    <meta
      property="article:published_time"
      content={new Date(publishDate).toISOString()}
    />
  )
}

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image" />
<meta property="twitter:url" content={canonicalURL} />
<meta property="twitter:title" content={title} />
<meta property="twitter:description" content={description} />
<meta property="twitter:image" content={socialImageURL} />

<ViewTransitions />

<!-- This is intentionally inlined to avoid FOUC -->
<script is:inline>
  const root = document.documentElement;
  const theme = localStorage.getItem("theme");
  if (
    theme === "dark" ||
    (!theme && window.matchMedia("(prefers-color-scheme: dark)").matches)
  ) {
    root.classList.add("theme-dark");
  } else {
    root.classList.remove("theme-dark");
  }
</script>

<!-- Twitter Widget Script -->
<script is:inline>
  window.twttr = (function (d, s, id) {
    var js,
      fjs = d.getElementsByTagName(s)[0],
      t = window.twttr || {};
    if (d.getElementById(id)) return t;
    js = d.createElement(s);
    js.id = id;
    js.src = "https://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js, fjs);

    t._e = [];
    t.ready = function (f) {
      t._e.push(f);
    };

    return t;
  })(document, "script", "twitter-wjs");

  // Function to load Twitter widgets
  function loadTwitterWidgets() {
    if (window.twttr && window.twttr.widgets) {
      window.twttr.widgets.load();
    }
  }

  // Load on initial page load
  document.addEventListener("DOMContentLoaded", loadTwitterWidgets);

  // Load on Astro page transitions
  document.addEventListener("astro:page-load", loadTwitterWidgets);

  // Load when Twitter script is ready
  window.twttr.ready(loadTwitterWidgets);
</script>

<!-- Mermaid Script -->
<script type="module">
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  // ===== Configuration Constants =====
  const MOBILE_BREAKPOINT = 768;
  const MOBILE_DIAGRAM_WIDTH = 900;
  const RESIZE_DEBOUNCE_MS = 150;

  // Utility function for mobile detection
  const isMobile = () => window.innerWidth <= MOBILE_BREAKPOINT;

  // ===== Shared Mermaid Configuration =====
  const mermaidDiagramConfig = {
    flowchart: {
      useMaxWidth: false,
      htmlLabels: true,
      curve: "basis",
    },
    gantt: {
      titleTopMargin: 25,
      barHeight: 30,
      barGap: 4,
      topPadding: 50,
      leftPadding: 75,
      gridLineStartPadding: 35,
      fontSize: 12,
      numberSectionStyles: 4,
      axisFormat: "%b '%y",
      useMaxWidth: false,
    },
  };

  // Function to get current theme
  function getCurrentTheme() {
    return document.documentElement.classList.contains("theme-dark")
      ? "dark"
      : "light";
  }

  // Function to get Mermaid theme variables based on current theme
  function getMermaidThemeVariables(theme) {
    if (theme === "dark") {
      return {
        primaryColor: "#ff6b6b",
        primaryTextColor: "#f4f4f5",
        primaryBorderColor: "#ff6b6b",
        lineColor: "#a1a1aa",
        secondaryColor: "#18181b",
        tertiaryColor: "#09090b",
        background: "#09090b",
        mainBkg: "#18181b",
        secondBkg: "#27272a",
        tertiaryBkg: "#3f3f46",
        textColor: "#f4f4f5",
        nodeTextColor: "#f4f4f5",
        nodeLabelColor: "#f4f4f5",
        nodeLabelBackgroundColor: "#18181b",
        labelTextColor: "#f4f4f5",
        gridColor: "#3f3f46",
        border1: "#3f3f46",
        border2: "#52525b",
        altSectionBkg: "#27272a",
        sectionBkg: "#18181b",
        sectionBkgColor: "#18181b",
        sectionBkgColor2: "#27272a",
        pieTitleTextColor: "#f4f4f5",
        pieOuterStrokeColor: "#f4f4f4",
        pieSectionTextColor: "#f4f4f4",
        pieLegendTextColor: "#f4f4f5",
        pieOuterStrokeWidth: "2px",
        taskTextColor: "#f4f4f5",
        taskTextLightColor: "#f4f4f5",
        taskTextDarkColor: "#18181b",
        taskTextOutsideColor: "#f4f4f5",
        sectionTitleColor: "#f4f4f5",
        todayLineColor: "#ff6b6b",
        edgeLabelBackground: "#27272a",
        clusterBkg: "#27272a",
        clusterBorder: "#3f3f46",
        titleColor: "#f4f4f5",
      };
    } else {
      return {
        primaryColor: "#ff6b6b",
        primaryTextColor: "#333",
        primaryBorderColor: "#ff6b6b",
        lineColor: "#666",
        secondaryColor: "#f9f9f9",
        tertiaryColor: "#fff",
        background: "#ffffff",
        mainBkg: "#ffffff",
        secondBkg: "#f9f9f9",
        tertiaryBkg: "#f0f0f0",
        textColor: "#333",
        nodeTextColor: "#333",
        nodeLabelColor: "#333",
        nodeLabelBackgroundColor: "#ffffff",
        gridColor: "#cccccc",
        border1: "#cccccc",
        border2: "#999999",
        altSectionBkg: "#f9f9f9",
        pieTitleTextColor: "#333",
        pieOuterStrokeColor: "#333333",
        pieSectionTextColor: "#333333",
        pieOuterStrokeWidth: "2px",
      };
    }
  }

  // Build complete mermaid config with theme
  function buildMermaidConfig(startOnLoad = true) {
    return {
      startOnLoad,
      theme: "default",
      themeVariables: getMermaidThemeVariables(getCurrentTheme()),
      ...mermaidDiagramConfig,
    };
  }

  // Initialize Mermaid with theme detection
  function initializeMermaid() {
    mermaid.initialize(buildMermaidConfig(true));
  }

  // Initialize on load
  initializeMermaid();

  // ===== Event Handler Management for Cleanup =====
  let resizeHandler = null;
  let resizeTimeout = null;

  function setupResizeHandler() {
    // Clean up any existing handler first
    cleanupResizeHandler();

    resizeHandler = () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        scaleMermaidDiagramsForMobile();
      }, RESIZE_DEBOUNCE_MS);
    };

    window.addEventListener("resize", resizeHandler);
  }

  function cleanupResizeHandler() {
    if (resizeHandler) {
      window.removeEventListener("resize", resizeHandler);
      resizeHandler = null;
    }
    if (resizeTimeout) {
      clearTimeout(resizeTimeout);
      resizeTimeout = null;
    }
  }

  // Function to render Mermaid diagrams
  function renderMermaidDiagrams() {
    const selectors = [
      "pre code.language-mermaid",
      "code.language-mermaid",
      'pre[class*="language-mermaid"]',
      'code[class*="language-mermaid"]',
      "pre:has(code.language-mermaid)",
      ".astro-code.language-mermaid",
    ];

    let mermaidElements = [];
    selectors.forEach((selector) => {
      try {
        const elements = document.querySelectorAll(selector);
        mermaidElements = [...mermaidElements, ...elements];
      } catch (e) {
        // Skip selectors that aren't supported
      }
    });

    // Also check for any pre elements containing Mermaid diagram keywords
    const preElements = document.querySelectorAll("pre");
    const mermaidKeywords = [
      "graph TB",
      "graph TD",
      "graph LR",
      "graph RL",
      "flowchart",
      "sequenceDiagram",
      "classDiagram",
      "stateDiagram",
      "erDiagram",
      "gantt",
      "pie title",
      "pie ",
      "journey",
      "gitGraph",
      "C4Context",
      "mindmap",
      "timeline",
    ];

    preElements.forEach((pre) => {
      const text = pre.textContent || pre.innerText;
      if (mermaidKeywords.some((keyword) => text.includes(keyword))) {
        mermaidElements.push(pre);
      }
    });

    console.log("Found mermaid elements:", mermaidElements.length);

    const mobile = isMobile();

    mermaidElements.forEach((element, index) => {
      // Skip if already processed
      if (element.classList.contains("mermaid-processed")) return;

      const mermaidCode = element.textContent || element.innerText;
      console.log(
        "Processing mermaid code:",
        mermaidCode.substring(0, 50) + "...",
      );

      const mermaidId = `mermaid-${index}-${Date.now()}`;

      // Create a div to hold the rendered diagram
      const mermaidDiv = document.createElement("div");
      mermaidDiv.id = mermaidId;
      mermaidDiv.className = "mermaid";
      mermaidDiv.textContent = mermaidCode.trim();

      const parent = element.closest("pre") || element;

      if (mobile) {
        // Create wrapper with fixed width so Mermaid renders at desktop size
        const wrapper = document.createElement("div");
        wrapper.className = "mermaid-mobile-wrapper";

        // Force the mermaid container to render at a fixed large width
        mermaidDiv.style.width = `${MOBILE_DIAGRAM_WIDTH}px`;
        mermaidDiv.style.minWidth = `${MOBILE_DIAGRAM_WIDTH}px`;
        mermaidDiv.style.transformOrigin = "top left";

        wrapper.appendChild(mermaidDiv);
        parent.parentNode.replaceChild(wrapper, parent);
      } else {
        parent.parentNode.replaceChild(mermaidDiv, parent);
      }

      // Mark as processed
      mermaidDiv.classList.add("mermaid-processed");
    });

    // Re-run mermaid and setup handlers ONLY AFTER rendering is complete
    if (mermaidElements.length > 0) {
      mermaid.run().then(() => {
        setupMermaidClickHandlers();
        // Only scale ONCE after mermaid finishes rendering
        if (mobile) {
          scaleMermaidDiagramsForMobile();
        }
        // Setup resize handler after initial render
        setupResizeHandler();
      });
    } else {
      setupMermaidClickHandlers();
      setupResizeHandler();
    }
  }

  // Function to scale Mermaid diagrams for mobile screens
  // Optimized: Uses cached SVG dimensions to avoid forced reflows
  function scaleMermaidDiagramsForMobile() {
    const mobile = isMobile();
    const diagrams = document.querySelectorAll(".mermaid");

    diagrams.forEach((diagram) => {
      const existingWrapper = diagram.parentElement;
      const isWrapped = existingWrapper?.classList.contains(
        "mermaid-mobile-wrapper",
      );

      if (mobile) {
        // Wrap if not already wrapped (edge case: resize from desktop to mobile)
        if (!isWrapped) {
          const wrapper = document.createElement("div");
          wrapper.className = "mermaid-mobile-wrapper";
          diagram.parentNode.insertBefore(wrapper, diagram);
          wrapper.appendChild(diagram);
        }

        const wrapper = diagram.parentElement;
        const containerWidth = wrapper.clientWidth || window.innerWidth - 32;
        const scale = Math.min(1, containerWidth / MOBILE_DIAGRAM_WIDTH);

        const svg = diagram.querySelector("svg");
        if (svg) {
          // Use SVG's viewBox or actual dimensions - avoid forcing reflow
          // Get height from SVG's intrinsic size or computed style
          let unscaledHeight;

          // Check if we have cached dimensions
          if (diagram.dataset.cachedHeight) {
            unscaledHeight = parseFloat(diagram.dataset.cachedHeight);
          } else {
            // First time: need to measure, but do it efficiently
            // Use requestAnimationFrame to batch layout reads
            const svgHeight = svg.getAttribute("height");
            const viewBox = svg.getAttribute("viewBox");

            if (svgHeight && !svgHeight.includes("%")) {
              unscaledHeight = parseFloat(svgHeight);
            } else if (viewBox) {
              const parts = viewBox.split(/\s+|,/);
              unscaledHeight = parseFloat(parts[3]) || 300;
            } else {
              // Fallback: read from bounding rect (single read, cached)
              unscaledHeight = svg.getBoundingClientRect().height;
            }

            // Add padding from .mermaid container (1rem = ~16px top + bottom)
            unscaledHeight += 32;

            // Cache for future resize events
            diagram.dataset.cachedHeight = unscaledHeight;
          }

          // Apply scale and store as CSS variable for button counter-scaling
          diagram.style.setProperty("--mermaid-scale", scale);
          diagram.style.transform = `scale(${scale})`;

          // Set wrapper height
          const scaledHeight = unscaledHeight * scale + 16;
          wrapper.style.height = `${scaledHeight}px`;
        } else {
          diagram.style.setProperty("--mermaid-scale", scale);
          diagram.style.transform = `scale(${scale})`;
        }
      } else {
        // Desktop: remove wrapper if it exists
        if (isWrapped) {
          existingWrapper.parentNode.insertBefore(diagram, existingWrapper);
          existingWrapper.remove();
        }
        // Reset transforms and cached data
        diagram.style.transform = "";
        diagram.style.minWidth = "";
        diagram.style.width = "";
        delete diagram.dataset.cachedHeight;
      }
    });
  }

  // ===== Shared Modal Logic =====

  // Global cleanup for modal listeners to prevent accumulation across page transitions
  if (window.modalCleanupRegistry) {
    window.modalCleanupRegistry.forEach((cleanup) => cleanup());
  }
  window.modalCleanupRegistry = [];

  class ZoomPanModal {
    constructor(config) {
      this.config = config;
      this.modal = null;
      this.container = null;
      this.zoomLevelDisplay = null;
      this.currentZoom = 1;
      this.isPanning = false;
      this.startX = 0;
      this.startY = 0;
      this.scrollLeft = 0;
      this.scrollTop = 0;
      this.initialTouchDistance = 0;
      this.lastTouchX = 0;
      this.lastTouchY = 0;

      this.createDOM();
      this.setupGlobalEvents();
      this.setupElementEvents();
    }

    createDOM() {
      // If modal exists in DOM, use it (unlikely with View Transitions if body swapped)
      // If it exists but we lost reference, re-acquire it.
      if (document.getElementById(this.config.modalId)) {
        this.modal = document.getElementById(this.config.modalId);
        this.container = this.modal.querySelector(".modal-content-container");
        this.zoomLevelDisplay = this.modal.querySelector(".modal-zoom-level");
        return;
      }

      // Lucide icons
      const icons = {
        zoomIn: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" x2="16.65" y1="21" y2="16.65"/><line x1="11" x2="11" y1="8" y2="14"/><line x1="8" x2="14" y1="11" y2="11"/></svg>`,
        zoomOut: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" x2="16.65" y1="21" y2="16.65"/><line x1="8" x2="14" y1="11" y2="11"/></svg>`,
        reset: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>`,
        close: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>`,
      };

      this.modal = document.createElement("div");
      this.modal.id = this.config.modalId;
      // Use common class plus specific one if needed
      this.modal.className = `mermaid-modal-overlay ${this.config.overlayClass || ""}`; // Reuse existing CSS class for overlay

      this.modal.innerHTML = `
        <div class="mermaid-modal-content ${this.config.contentClass || ""}">
          <div class="mermaid-modal-controls">
            <button class="mermaid-modal-btn" data-action="zoom-out" title="Zoom Out">${icons.zoomOut}</button>
            <span class="mermaid-modal-zoom-info modal-zoom-level">100%</span>
            <button class="mermaid-modal-btn" data-action="zoom-in" title="Zoom In">${icons.zoomIn}</button>
            <div class="mermaid-modal-divider"></div>
            <button class="mermaid-modal-btn" data-action="reset" title="Reset">${icons.reset}</button>
            <button class="mermaid-modal-btn" data-action="close" title="Close">${icons.close}</button>
          </div>
          <div class="mermaid-modal-diagram modal-content-container" style="display: flex;"></div>
          <div class="mermaid-modal-hint">Scroll to zoom â€¢ Drag to pan</div>
        </div>
      `;

      document.body.appendChild(this.modal);
      this.container = this.modal.querySelector(".modal-content-container");
      this.zoomLevelDisplay = this.modal.querySelector(".modal-zoom-level");
    }

    setupGlobalEvents() {
      // Keyboard (Global)
      const keydownHandler = (e) => {
        if (
          e.key === "Escape" &&
          this.modal &&
          this.modal.classList.contains("active")
        ) {
          this.close();
        }
      };

      // Remove existing listener if any (to be safe, though usage pattern implies singleton)
      if (this.keydownHandler)
        document.removeEventListener("keydown", this.keydownHandler);
      this.keydownHandler = keydownHandler;
      document.addEventListener("keydown", keydownHandler);

      // Cleanup Registry for total script re-runs
      window.modalCleanupRegistry.push(() => {
        document.removeEventListener("keydown", keydownHandler);
      });

      // Browser Back Button Support (Global)
      const popstateHandler = () => {
        // Check if modal exists and is active
        if (
          this.modal &&
          this.modal.classList.contains("active") &&
          window.location.hash !== this.config.urlHash
        ) {
          this.close(false);
        }
      };

      if (this.popstateHandler)
        window.removeEventListener("popstate", this.popstateHandler);
      this.popstateHandler = popstateHandler;
      window.addEventListener("popstate", popstateHandler);

      window.modalCleanupRegistry.push(() => {
        window.removeEventListener("popstate", popstateHandler);
      });
    }

    setupElementEvents() {
      // Buttons
      this.modal.addEventListener("click", (e) => {
        const btn = e.target.closest("button");
        if (btn) {
          const action = btn.dataset.action;
          if (action === "zoom-in") this.zoomIn();
          if (action === "zoom-out") this.zoomOut();
          if (action === "reset") this.resetZoom();
          if (action === "close") this.close();
        } else if (e.target === this.modal) {
          this.close();
        }
      });

      // Wheel Zoom
      this.container.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          if (e.deltaY < 0) this.zoomIn();
          else this.zoomOut();
        },
        { passive: false },
      );

      // Pan (Mouse)
      this.container.addEventListener("mousedown", (e) => {
        e.preventDefault();
        this.isPanning = true;
        this.container.style.cursor = "grabbing";
        this.startX = e.pageX - this.container.offsetLeft;
        this.startY = e.pageY - this.container.offsetTop;
        this.scrollLeft = this.container.scrollLeft;
        this.scrollTop = this.container.scrollTop;
      });

      this.container.addEventListener("mousemove", (e) => {
        if (!this.isPanning) return;
        e.preventDefault();
        const x = e.pageX - this.container.offsetLeft;
        const y = e.pageY - this.container.offsetTop;
        const walkX = (x - this.startX) * 1.5;
        const walkY = (y - this.startY) * 1.5;
        this.container.scrollLeft = this.scrollLeft - walkX;
        this.container.scrollTop = this.scrollTop - walkY;
      });

      this.container.addEventListener("mouseup", () => this.stopPan());
      this.container.addEventListener("mouseleave", () => this.stopPan());

      // Pan & Zoom (Touch)
      this.container.addEventListener(
        "touchstart",
        (e) => {
          if (e.touches.length === 2) {
            this.initialTouchDistance = Math.hypot(
              e.touches[0].pageX - e.touches[1].pageX,
              e.touches[0].pageY - e.touches[1].pageY,
            );
          } else if (e.touches.length === 1) {
            this.isPanning = true;
            this.lastTouchX = e.touches[0].pageX;
            this.lastTouchY = e.touches[0].pageY;
            this.scrollLeft = this.container.scrollLeft;
            this.scrollTop = this.container.scrollTop;
          }
        },
        { passive: false },
      );

      this.container.addEventListener(
        "touchmove",
        (e) => {
          e.preventDefault();
          if (e.touches.length === 2) {
            const newDistance = Math.hypot(
              e.touches[0].pageX - e.touches[1].pageX,
              e.touches[0].pageY - e.touches[1].pageY,
            );
            const delta = newDistance - this.initialTouchDistance;
            if (Math.abs(delta) > 10) {
              if (delta > 0)
                this.currentZoom = Math.min(this.currentZoom * 1.05, 5);
              else this.currentZoom = Math.max(this.currentZoom * 0.95, 0.25);
              this.updateZoom(false); // Smooth zoom
              this.initialTouchDistance = newDistance;
            }
          } else if (e.touches.length === 1 && this.isPanning) {
            const touchX = e.touches[0].pageX;
            const touchY = e.touches[0].pageY;
            const walkX = touchX - this.lastTouchX;
            const walkY = touchY - this.lastTouchY;
            this.container.scrollLeft = this.scrollLeft - walkX;
            this.container.scrollTop = this.scrollTop - walkY;
          }
        },
        { passive: false },
      );

      this.container.addEventListener("touchend", () => {
        this.isPanning = false;
        this.initialTouchDistance = 0;
      });
    }

    setupEvents() {
      // Deprecated in favor of split setup
    }

    stopPan() {
      this.isPanning = false;
      this.container.style.cursor = "grab";
    }

    updateZoom(centerAfterZoom = true) {
      if (!this.container) return;
      const content = this.container.firstElementChild; // Wrapper
      const target = content?.firstElementChild; // SVG or IMG

      if (content && target) {
        const originalWidth = parseFloat(this.container.dataset.originalWidth);
        const originalHeight = parseFloat(
          this.container.dataset.originalHeight,
        );

        // Apply Scale
        target.style.transform = `scale(${this.currentZoom})`;
        target.style.transformOrigin = "top left";
        this.zoomLevelDisplay.textContent = `${Math.round(this.currentZoom * 100)}%`;

        // Resize Wrapper
        const scaledWidth = originalWidth * this.currentZoom;
        const scaledHeight = originalHeight * this.currentZoom;
        content.style.width = `${scaledWidth}px`;
        content.style.height = `${scaledHeight}px`;
        content.style.margin = "auto"; // Auto margins center in flex container

        if (centerAfterZoom && this.currentZoom <= 1.0) {
          this.container.scrollLeft = 0;
          this.container.scrollTop = 0;
        }
      }
    }

    zoomIn() {
      this.currentZoom = Math.min(this.currentZoom * 1.25, 5);
      this.updateZoom(true);
    }

    zoomOut() {
      this.currentZoom = Math.max(this.currentZoom * 0.8, 0.25);
      this.updateZoom(true);
    }

    resetZoom() {
      this.currentZoom = 1;
      this.updateZoom(true);
    }

    open(contentNode, width, height) {
      // REBINDING LOGIC: Check if modal is still valid in current DOM
      if (!this.modal || !document.body.contains(this.modal)) {
        console.log(`Recreating disconnected modal for ${this.config.modalId}`);
        this.createDOM();
        this.setupElementEvents();
      }

      this.container.innerHTML = "";

      // Create Wrapper
      const wrapper = document.createElement("div");
      wrapper.className = this.config.wrapperClass;
      // Needed for pointer events to pass through wrapper to container for panning
      wrapper.style.pointerEvents = "none";

      // Clone & Setup Content
      const clonedContent = contentNode.cloneNode(true);
      clonedContent.style.transform = "scale(1)";
      clonedContent.style.transformOrigin = "top left";
      clonedContent.removeAttribute("class");
      if (this.config.contentAddClass)
        clonedContent.classList.add(this.config.contentAddClass);

      // Fix dimensions on clone if needed
      if (this.config.forceDimensions) {
        clonedContent.style.width = `${width}px`;
        clonedContent.style.height = `${height}px`;
      }

      wrapper.appendChild(clonedContent);
      this.container.appendChild(wrapper);

      // Store Original Dimensions
      this.container.dataset.originalWidth = width;
      this.container.dataset.originalHeight = height;

      // Calculate Initial Fit Zoom
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const paddingX = this.config.paddingX || 40;
      const paddingY = this.config.paddingY || 40;

      const fitWidth = (viewportWidth - paddingX) / width;
      const fitHeight = (viewportHeight - paddingY) / height;

      // Initial zoom: fit to screen, max 1.0
      this.currentZoom = Math.min(1, fitWidth, fitHeight);

      this.updateZoom(true);

      // Push history state - ONLY if not already there
      if (window.location.hash !== this.config.urlHash) {
        history.pushState(null, "", this.config.urlHash);
      }

      // Show Modal
      this.modal.classList.add("active");
      document.body.style.overflow = "hidden";

      // Force layout update for centering
      requestAnimationFrame(() => this.updateZoom(true));
    }

    close(historyBack = true) {
      // Add closing class first to trigger optimized exit animation
      // This immediately disables the expensive backdrop-filter on mobile
      this.modal.classList.add("closing");
      this.modal.classList.remove("active");
      document.body.style.overflow = "";
      this.currentZoom = 1;

      // Remove closing class after transition completes
      setTimeout(() => {
        if (this.modal) {
          this.modal.classList.remove("closing");
        }
      }, 200); // Match the CSS transition duration (0.15s + buffer)

      if (historyBack && window.location.hash === this.config.urlHash) {
        history.back();
      }
    }
  }

  // Initialize Modals
  const mermaidModal = new ZoomPanModal({
    modalId: "mermaid-modal",
    urlHash: "#mermaid-preview",
    wrapperClass: "mermaid-svg-wrapper",
    paddingX: 40,
    paddingY: 40,
  });

  const imageModal = new ZoomPanModal({
    modalId: "image-modal",
    urlHash: "#image-preview",
    wrapperClass: "image-wrapper",
    contentAddClass: "image-modal-img", // Class for image styling
    overlayClass: "image-modal-overlay", // For specific styling if needed
    forceDimensions: true,
    paddingX: 40,
    paddingY: 90,
  });

  // Open Mermaid Diagram
  function openMermaidModal(diagramElement) {
    const svg = diagramElement.querySelector("svg");
    if (svg) {
      const rect = svg.getBoundingClientRect();
      // For SVGs, we use getBoundingClientRect as reliable source of 'natural' size
      mermaidModal.open(svg, rect.width, rect.height);
    }
  }

  // Open Image
  function openImageModal(imgElement) {
    // Use natural width/height for images if available (better quality), fallback to rect
    const width = imgElement.naturalWidth || imgElement.clientWidth;
    const height = imgElement.naturalHeight || imgElement.clientHeight;
    imageModal.open(imgElement, width, height);
  }

  // Setup click handlers for all mermaid diagrams
  function setupMermaidClickHandlers() {
    const diagrams = document.querySelectorAll(".mermaid");
    diagrams.forEach((diagram) => {
      // Skip if already has click handler
      if (diagram.dataset.hasClickHandler) return;

      diagram.dataset.hasClickHandler = "true";
      diagram.style.cursor = "pointer";
      diagram.title = "Click to expand diagram";

      diagram.addEventListener("click", () => {
        openMermaidModal(diagram);
      });
    });
  }

  // Function to update Mermaid theme and re-render diagrams
  function updateMermaidTheme() {
    const currentTheme = getCurrentTheme();

    // Update Mermaid configuration with new theme variables
    mermaid.initialize(buildMermaidConfig(false));

    // Re-render all existing Mermaid diagrams with new theme
    const existingMermaidDiagrams = document.querySelectorAll(".mermaid");
    if (existingMermaidDiagrams.length > 0) {
      mermaid.run();
    }
  }

  // Function to handle theme changes
  function handleThemeChange() {
    updateMermaidTheme();
  }

  // Listen for theme changes
  const themeObserver = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (
        mutation.type === "attributes" &&
        mutation.attributeName === "class"
      ) {
        const target = mutation.target;
        if (target === document.documentElement) {
          handleThemeChange();
        }
      }
    });
  });

  // Start observing theme changes
  themeObserver.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ["class"],
  });

  // Function to wrap wide tables in scrollable containers
  function wrapWideTables() {
    const tables = document.querySelectorAll("table");

    tables.forEach((table, index) => {
      // Skip if already wrapped
      if (table.parentElement.classList.contains("table-scroll-container")) {
        return;
      }

      // Check if table is wider than its container
      const tableRect = table.getBoundingClientRect();
      const containerRect = table.parentElement.getBoundingClientRect();

      // If table is wider than container or if we're on mobile, wrap it
      const isOnMobile = window.innerWidth <= 768;
      const isTableTooWide = tableRect.width > containerRect.width;

      if (isTableTooWide || isOnMobile) {
        // Create scrollable container
        const scrollContainer = document.createElement("div");
        scrollContainer.className = "table-scroll-container";

        // Insert container before table
        table.parentElement.insertBefore(scrollContainer, table);

        // Move table into container
        scrollContainer.appendChild(table);

        console.log(`Wrapped table ${index + 1} in scrollable container`);
      }
    });
  }

  // Re-wrap tables on window resize
  let tableResizeTimeout;

  function handleTableResize() {
    clearTimeout(tableResizeTimeout);
    tableResizeTimeout = setTimeout(() => {
      wrapWideTables();
    }, 250);
  }

  // Add cleanup for table resize listener
  window.addEventListener("resize", handleTableResize);

  // Setup click handlers for images in content areas
  function setupImageClickHandlers() {
    // Select images within .content areas (blog posts)
    const images = document.querySelectorAll(".content img");

    images.forEach((img) => {
      // Skip if already has click handler
      if (img.dataset.hasModalHandler) return;

      // Skip small images (likely icons) and images inside links
      if (img.closest("a")) return;

      img.dataset.hasModalHandler = "true";
      img.style.cursor = "pointer";
      img.title = "Click to expand image";
      img.classList.add("image-expandable");

      img.addEventListener("click", (e) => {
        e.preventDefault();
        openImageModal(img);
      });
    });
  }

  // Render on initial load
  document.addEventListener("DOMContentLoaded", () => {
    try {
      renderMermaidDiagrams();
    } catch (e) {
      console.warn("Mermaid init error:", e);
    }
    try {
      wrapWideTables();
    } catch (e) {
      console.warn("Table wrapper error:", e);
    }
    try {
      setupImageClickHandlers();
    } catch (e) {
      console.warn("Image handler error:", e);
    }
  });

  // Render on Astro page transitions
  document.addEventListener("astro:page-load", () => {
    try {
      renderMermaidDiagrams();
    } catch (e) {
      console.warn("Mermaid page-load error:", e);
    }
    try {
      wrapWideTables();
    } catch (e) {
      console.warn("Table wrapper error:", e);
    }
    try {
      setupImageClickHandlers();
    } catch (e) {
      console.warn("Image handler error:", e);
    }
  });
</script>
