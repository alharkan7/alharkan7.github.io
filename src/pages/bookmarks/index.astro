---
import BaseLayout from "../../layouts/BaseLayout.astro";
import bookmarksDataUntyped from "../../../public/os-bookmarks/chrome_bookmarks.json" assert { type: "json" };
import BookmarkNodeComponent from "../../components/BookmarkNode.astro"; // Import the new component
import type {
    BookmarkNode,
    BookmarkFolder as BookmarkFolderType,
} from "../../components/BookmarkNode.astro"; // Import types

// Define ONLY the top-level BookmarkData type here
interface BookmarkFolder {
    type: "folder";
    id: string;
    name: string;
    date_added: string;
    date_modified?: string;
    guid: string;
    children: any[]; // Use any temporarily, full types are in the component
}

interface BookmarkData {
    roots: {
        bookmark_bar: BookmarkFolder;
        other: BookmarkFolder;
        synced?: BookmarkFolder;
        [key: string]: BookmarkFolder | undefined;
    };
}

// Cast the imported data
const bookmarkRoots = bookmarksDataUntyped as unknown as BookmarkData["roots"];

const title = "My Bookmarks";
const description = "Al Harkan's Bookmarks";
const permalink = Astro.site?.href
    ? `${Astro.site.href}bookmarks`
    : "/bookmarks";

// Define the list of allowed top-level folder names
const allowedFolderNames = [
    "AI",
    "Startups & Business",
    "Tech & Engineering",
    "Research",
    "Academic Tools",
    "Reference/Citation Map",
    "Design & Marketing",
    "Journalism",
];

// Prepare the roots to iterate over (handle potential undefined)
const rootsToRender = [bookmarkRoots.bookmark_bar, bookmarkRoots.other].filter(
    Boolean,
) as BookmarkFolderType[]; // Cast to proper type

// --- Add URL Counting Logic ---
const countUrls = (node: BookmarkNode): number => {
    if (!node) return 0; // Guard against null/undefined nodes if data is imperfect
    if (node.type === "url") {
        return 1;
    } else if (node.type === "folder") {
        // Recursively count URLs in children
        return node.children.reduce(
            (sum: number, child: BookmarkNode) => sum + countUrls(child),
            0,
        );
    }
    return 0; // Handle other types or errors gracefully
};

// Calculate total count only across the *allowed* folders that will be rendered
let totalUrlCount = 0;
rootsToRender.forEach((root: BookmarkFolderType) => {
    if (root.children) {
        root.children
            .filter(
                (node: BookmarkNode) =>
                    node.type === "folder" &&
                    allowedFolderNames.includes(node.name),
            )
            .forEach((allowedFolder: BookmarkNode) => {
                totalUrlCount += countUrls(allowedFolder); // Count URLs within each allowed folder
            });
    }
});
// --- End URL Counting Logic ---

// Remove the old renderBookmarkNode function
---

<BaseLayout
    title={title}
    description={description}
    permalink={permalink ?? "/"}
    current="bookmarks"
>
    <div class="container">
        <h1>My {totalUrlCount} Bookmarks</h1>
        <p>On AI Research, Business, Software, and Digital Media</p>
        <div>
            {
                rootsToRender.map(
                    (root: BookmarkFolderType) =>
                        // Iterate through the children of each main root ('bookmark_bar', 'other')
                        root.children &&
                        root.children
                            // Filter children: only include folders whose names are in the allowed list
                            .filter(
                                (node: BookmarkNode) =>
                                    node.type === "folder" &&
                                    allowedFolderNames.includes(node.name),
                            )
                            // Render the allowed folders, passing the allowed list down
                            .map((node: BookmarkNode) => (
                                <BookmarkNodeComponent
                                    node={node}
                                    allowedFolderNames={allowedFolderNames}
                                />
                            )),
                )
            }
        </div>
        <p>
            This bookmarks list is automatically updated daily and synced with
            my Chrome browser.
        </p>
    </div>
</BaseLayout>

<style>
    .container h1 {
        margin-block-start: 1em; /* Keep some top margin */
        margin-block-end: 0.5em; /* Reduce bottom margin */
        /* You could use padding-top/padding-bottom instead if needed */
        padding-left: 0.25em;
    }

    .container p {
        padding-left: 0.5em;
    }

    /* Add margin to the div containing the bookmark list */
    .container > div {
        margin-block-start: 3em; /* Margin above the list */
        margin-block-end: 3em; /* Margin below the list */
    }

    /* Style the last paragraph as a footnote */
    .container p:last-of-type {
        font-size: 0.85em; /* Smaller font size */
        color: var(--text-secondary, grey); /* Muted color */
        margin-top: 2em; /* Add some space above it */
    }
</style>
