---
import BaseLayout from "../../layouts/BaseLayout.astro";
import bookmarksDataUntyped from "../../../public/os-bookmarks/chrome_bookmarks.json" assert { type: "json" };
import BookmarkNodeComponent from "../../components/BookmarkNode.astro"; // Import the new component
import type {
    BookmarkNode,
    BookmarkFolder as BookmarkFolderType,
} from "../../components/BookmarkNode.astro"; // Import types

// Define ONLY the top-level BookmarkData type here
interface BookmarkFolder {
    type: "folder";
    id: string;
    name: string;
    date_added: string;
    date_modified?: string;
    guid: string;
    children: any[]; // Use any temporarily, full types are in the component
}

interface BookmarkData {
    roots: {
        bookmark_bar: BookmarkFolder;
        other: BookmarkFolder;
        synced?: BookmarkFolder;
        [key: string]: BookmarkFolder | undefined;
    };
}

// Cast the imported data
const bookmarkRoots = bookmarksDataUntyped as unknown as BookmarkData["roots"];

const title = "Bookmarks - Al Harkan";
const description = "Bookmarks on AI Research, Business, Software, and Digital Media";
const permalink = Astro.site?.href
    ? `${Astro.site.href}bookmarks`
    : "/bookmarks";

// Define the list of allowed top-level folder names
const allowedFolderNames = [
    "AI",
    "Startups & Business",
    "Tech & Engineering",
    "Research",
    "Academic Tools",
    "Reference/Citation Map",
    "Design & Marketing",
    "Journalism",
];

// Prepare the roots to iterate over (handle potential undefined)
const rootsToRender = [bookmarkRoots.bookmark_bar, bookmarkRoots.other].filter(
    Boolean,
) as BookmarkFolderType[]; // Cast to proper type

// --- Add URL Counting Logic ---
const countUrls = (node: BookmarkNode): number => {
    if (!node) return 0; // Guard against null/undefined nodes if data is imperfect
    if (node.type === "url") {
        return 1;
    } else if (node.type === "folder") {
        // Recursively count URLs in children
        return node.children.reduce(
            (sum: number, child: BookmarkNode) => sum + countUrls(child),
            0,
        );
    }
    return 0; // Handle other types or errors gracefully
};

// Calculate total count only across the *allowed* folders that will be rendered
let totalUrlCount = 0;
rootsToRender.forEach((root: BookmarkFolderType) => {
    if (root.children) {
        root.children
            .filter(
                (node: BookmarkNode) =>
                    node.type === "folder" &&
                    allowedFolderNames.includes(node.name),
            )
            .forEach((allowedFolder: BookmarkNode) => {
                totalUrlCount += countUrls(allowedFolder); // Count URLs within each allowed folder
            });
    }
});
// --- End URL Counting Logic ---

// Remove the old renderBookmarkNode function
---

<BaseLayout
    title={title}
    description={description}
    permalink={permalink ?? "/"}
    current="bookmarks"
>
    <div class="container">
        <h1>My {totalUrlCount} Bookmarks</h1>
        <p>On AI Research, Business, Software, and Digital Media</p>
        <hr />
        <div>
            {
                rootsToRender.map(
                    (root: BookmarkFolderType) =>
                        // Iterate through the children of each main root ('bookmark_bar', 'other')
                        root.children &&
                        root.children
                            // Filter children: only include folders whose names are in the allowed list
                            .filter(
                                (node: BookmarkNode) =>
                                    node.type === "folder" &&
                                    allowedFolderNames.includes(node.name),
                            )
                            // Render the allowed folders, passing the allowed list down
                            .map((node: BookmarkNode) => (
                                <BookmarkNodeComponent
                                    node={node}
                                    allowedFolderNames={allowedFolderNames}
                                />
                            )),
                )
            }
        </div>
        <p>
            This bookmarks list is automatically updated daily and synced with
            my Chrome browser.
        </p>
    </div>
</BaseLayout>

<script>
    // Select the container holding the top-level bookmark folders
    const bookmarkContainer = document.querySelector('.container > div');

    if (bookmarkContainer) {
        bookmarkContainer.addEventListener('toggle', (event) => {
            const target = event.target as HTMLElement; // Cast to HTMLElement first

            // Check if the event target is a <details> element and if it was opened
            // AND ensure the target is a DIRECT CHILD of the container
            if (target && target.tagName === 'DETAILS' && target.parentElement === bookmarkContainer && (target as HTMLDetailsElement).open) {
                // Cast target specifically to HTMLDetailsElement for accessing .open
                const openedDetails = target as HTMLDetailsElement;

                // Get all direct children <details> elements within the container
                // Cast the NodeListOf<Element> to HTMLDetailsElement[]
                const allDetails = Array.from(bookmarkContainer.querySelectorAll<HTMLDetailsElement>(':scope > details'));

                // Close all other <details> elements
                allDetails.forEach(details => {
                    // Now 'details' is correctly typed as HTMLDetailsElement
                    if (details !== openedDetails) {
                        details.open = false;
                    }
                });
            }
        }, true); // Use capture phase to potentially handle nested toggles if needed later
    }
</script>

<style>
    .container h1 {
        margin-block-start: 1em; /* Keep some top margin */
        margin-block-end: 0.5em; /* Reduce bottom margin */
        /* You could use padding-top/padding-bottom instead if needed */
    }

    /* Add margin to the div containing the bookmark list */
    .container > div {
        margin-block-start: 3em; /* Margin above the list */
        margin-block-end: 3em; /* Margin below the list */
    }

    /* Style the last paragraph as a footnote */
    .container p:last-of-type {
        font-size: 0.85em; /* Smaller font size */
        color: var(--text-secondary, grey); /* Muted color */
        margin-top: 2em; /* Add some space above it */
    }
</style>
