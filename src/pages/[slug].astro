---
import BaseLayout from "../layouts/BaseLayout.astro";
import Bio from "../components/Bio.astro";
import HeadingsMap from "../components/HeadingsMap.svelte";
import getPostData from "../utils/getPostData";
import { findRedirect } from "../utils/redirectHandler";

export const prerender = true;

export async function getStaticPaths() {
  const blogPostsGlob = import.meta.glob("../posts/blog/*.{md,mdx}", {
    eager: true,
  });
  const blogPosts: any = Object.values(blogPostsGlob);
  const storyPostsGlob = import.meta.glob(
    "../posts/stories/*.{md,mdx}",
    { eager: true },
  );
  const storyPosts: any = Object.values(storyPostsGlob);
  const workPostsGlob = import.meta.glob("../posts/misc/*.{md,mdx}", {
    eager: true,
  });
  const workPosts: any = Object.values(workPostsGlob);
  const uncategorizedPostsGlob = import.meta.glob(
    "../posts/uncategorized/*.{md,mdx}",
    { eager: true },
  );
  const uncategorizedPosts: any = Object.values(uncategorizedPostsGlob);
  const ptmPostsGlob = import.meta.glob("../posts/ptm/*.{md,mdx}", {
    eager: true,
  });
  const ptmPosts: any = Object.values(ptmPostsGlob);
  const scrollyPostsGlob = import.meta.glob("../posts/scrolly/*.{md,mdx}", {
    eager: true,
  });
  const scrollyPosts: any = Object.values(scrollyPostsGlob);
  const allPosts = [
    ...blogPosts,
    ...storyPosts,
    ...workPosts,
    ...uncategorizedPosts,
    ...ptmPosts,
    ...scrollyPosts,
  ];

  const postRoutes = allPosts.map((p) => ({
    params: { slug: p.file.split("/").pop().split(".").shift() },
    props: { post: p, type: 'post' },
  }));

  // Handle standalone HTML pages (flat files in src/featured/*.html)
  const htmlPagesGlob = import.meta.glob("../featured/*.html", {
    query: "?raw",
    eager: true,
  });
  
  const htmlRoutes = Object.entries(htmlPagesGlob).map(([path, content]) => ({
    params: { slug: path.split("/").pop()?.split(".").shift() || "" },
    props: { htmlContent: (content as any).default, type: "html" },
  }));

  // Handle subfolder HTML pages (src/featured/[name]/index.html)
  // Static assets for these pages go in public/featured/[name]/
  const htmlSubfolderGlob = import.meta.glob("../featured/*/index.html", {
    query: "?raw",
    eager: true,
  });

  const htmlSubfolderRoutes = Object.entries(htmlSubfolderGlob).map(([path, content]) => {
    // path looks like: ../components/media-election-2019/index.html
    const parts = path.split("/");
    const folderName = parts[parts.length - 2]; // e.g. "media-election-2019"
    return {
      params: { slug: folderName },
      props: { htmlContent: (content as any).default, type: "html" },
    };
  });

  return [...postRoutes, ...htmlRoutes, ...htmlSubfolderRoutes];
}

const { slug } = Astro.params;
const { post, htmlContent, type: initialType = "post" } = Astro.props;

let type = initialType;
let Content: any;
let frontmatter: any;
let title: string = "";
let description: string = "";
let publishDate: string = "";
let image: string = "";
let permalink: string = "";
let category: string = "";
let recommendedPosts: any[] = [];

if (type === "post") {
  // Check if post exists in props
  if (!post) {
    console.error(`Post not found for slug: ${slug}`);
    return Astro.redirect("/404");
  }

  Content = post.Content;
  frontmatter = post.frontmatter;

  // Check for redirection
  const redirectMatch = findRedirect(slug);

  // If a redirect is found, use Astro's redirect method
  if (redirectMatch) {
    return Astro.redirect(redirectMatch.destination);
  }

  title = frontmatter.title;
  description = frontmatter.description;
  publishDate = frontmatter.publishDate;
  image = frontmatter.image;

  const postData = getPostData(post);
  permalink = `${Astro.site?.href || ""}${postData.slug}`;

  // Check if this is a blog post or other category
  const possiblePaths = ["blog", "stories", "uncategorized", "misc", "ptm", "scrolly"];
  category =
    possiblePaths.find((path) => post.file.includes(`/posts/${path}/`)) || "";

  // Check if it's a scrolly post to handle layout differently
  const isScrolly = category === "scrolly" || (frontmatter.layout && (frontmatter.layout.includes("ScrollyLayout") || frontmatter.layout.includes("ScrollyTemplate")));

  if (isScrolly) {
    type = "scrolly";
  }

  // Get recommended posts from the same category
  const getRecommendedPosts = async () => {
    if (isScrolly) return [];
    let categoryPosts: any[] = [];
    if (category === "blog") {
      const glob = import.meta.glob("../posts/blog/*.{md,mdx}", {
        eager: true,
      });
      categoryPosts = Object.values(glob);
    } else if (category === "stories") {
      const glob = import.meta.glob("../posts/stories/*.{md,mdx}", {
        eager: true,
      });
      categoryPosts = Object.values(glob);
    } else if (category === "misc") {
      const glob = import.meta.glob("../posts/misc/*.{md,mdx}", {
        eager: true,
      });
      categoryPosts = Object.values(glob);
    } else if (category === "ptm") {
      const glob = import.meta.glob("../posts/ptm/*.{md,mdx}", {
        eager: true,
      });
      categoryPosts = Object.values(glob);
    } else {
      const glob = import.meta.glob("../posts/uncategorized/*.{md,mdx}", {
        eager: true,
      });
      categoryPosts = Object.values(glob);
    }

    return categoryPosts
      .filter((p: any) => p.file !== post.file)
      .sort(() => Math.random() - 0.5)
      .slice(0, 2)
      .map((p: any) => ({
        title: p.frontmatter.title,
        slug: p.file.split("/").pop().split(".").shift(),
      }));
  };

  recommendedPosts = await getRecommendedPosts();
}
---

{type === 'html' ? (
  <Fragment set:html={htmlContent} />
) : type === 'scrolly' ? (
  <Content />
) : (
  <BaseLayout
    title={title}
    description={description}
    permalink={permalink}
    current={category}
    type="article"
    publishDate={publishDate}
    image={image}
  >
    <!-- Headings Map Component -->
    <HeadingsMap client:load />

    <header>
      <!-- <p>{publishDate} ~ {readingTime}</p> -->
      <p>
        <a href={category === "blog" ? "/" : `/${category}`}>
          {category === "blog" ? "#featured" : `#${category}`}
        </a>
        ~ {publishDate}
      </p>
      <h1>{title}</h1>
      <hr />
    </header>
    <div class="container">
      <article class="content">
        <Content />
      </article>

      {
        recommendedPosts.length > 0 && (
          <div class="recommended-posts">
            <h3>
              Read more posts in{" "}
              <a href={category === "blog" ? "/" : `/${category}`}>
                {category === "blog" ? "#featured" : `#${category}`}
              </a>
            </h3>
            <div class="recommended-grid">
              {recommendedPosts.map((post: any) => (
                <a href={`/${post.slug}`} class="recommended-post">
                  {post.title}
                </a>
              ))}
            </div>
          </div>
        )
      }

      <hr />
      <Bio />
    </div>
  </BaseLayout>
)}

<style>
  header {
    text-align: center;
  }

  header h1 {
    margin-bottom: 0.7em;
  }

  header p {
    color: var(--text-secondary);
    font-family: var(--font-family-sans);
    font-weight: 500;
  }

  header hr {
    min-width: 100px;
    width: 30%;
  }

  .recommended-posts {
    margin-top: 2rem;
    padding-top: 2rem;
    border-top: 1px solid var(--text-secondary);
  }

  .recommended-posts h3 {
    text-align: center;
    margin-bottom: 1.5rem;
    color: var(--text-secondary);
    font-size: 1.2rem;
  }

  .recommended-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1rem;
  }

  .recommended-post {
    padding: 1rem;
    border: 1px solid var(--text-secondary);
    border-radius: 0.5rem;
    text-decoration: none;
    color: var(--text-regular);
    transition: all 0.2s ease;
    display: flex;
    justify-content: center;
    align-items: center;
    text-align: center;
    font-weight: 700;
  }

  .recommended-post:hover {
    /* background: var(--text-secondary);*/
    text-decoration: none;
    color: var(--primary-color);
    box-shadow: inset 0 -0.12em 0 var(--primary-color);
    -webkit-transition:
      box-shadow 0.2s ease-in-out,
      color 0.2s ease-in-out;
    transition:
      box-shadow 0.2s ease-in-out,
      color 0.2s ease-in-out;
  }
</style>
