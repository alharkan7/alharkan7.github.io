---
import BaseLayout from "../layouts/BaseLayout.astro";
import { readFile } from 'node:fs/promises'; // Import Node.js fs for build-time reading
import path from 'node:path';

// Define the expected structure of a video object
interface Video {
    title: string;
    thumbnail_url: string;
    url: string;
    video_owner_channel_id: string;
    video_owner_channel_title: string;
    published_at: string;
}

const title = "Videos - Al Harkan";
const description =
    "Videos Curation on AI Research, Software, and Digital Media";
const permalink = Astro.site?.href ? `${Astro.site.href}videos` : "/videos";

// --- Build-time Data Extraction for Filters & Count ---
let buildTimeVideosData: Video[] = [];
let totalItems = 0;
let uniqueYears: string[] = [];
let uniqueChannels: { id: string; title: string }[] = [];
let errorMessage: string | null = null;

try {
    // Construct the absolute path relative to the project root
    const jsonPath = path.resolve('public/os-bookmarks/liked_videos.json');
    // console.log(`Reading JSON from: ${jsonPath}`); // Debug path
    const jsonData = await readFile(jsonPath, 'utf-8');
    let allParsedVideos = JSON.parse(jsonData);

    // Filter out "Private video" entries *before* counting or processing
    buildTimeVideosData = allParsedVideos.filter((video: Video) => video.title !== "Private video");

    // Calculate total items based on the *filtered* data
    totalItems = buildTimeVideosData.length;

    // Now extract unique years and channels from the filtered data
    uniqueYears = [
        ...new Set(buildTimeVideosData.map((v) => v.published_at.substring(0, 4))),
].sort((a, b) => parseInt(b) - parseInt(a)); // Sort descending

const uniqueChannelsMap = new Map<string, string>();
    buildTimeVideosData.forEach((v) => {
        if (v.video_owner_channel_id && !uniqueChannelsMap.has(v.video_owner_channel_id)) {
        uniqueChannelsMap.set(
            v.video_owner_channel_id,
                v.video_owner_channel_title || 'Unknown Channel', // Provide fallback
        );
    }
});
    uniqueChannels = Array.from(uniqueChannelsMap.entries())
    .map(([id, title]) => ({ id, title }))
    .sort((a, b) => a.title.localeCompare(b.title)); // Sort alphabetically by title

    // Clear the large data structure after extracting info to prevent accidental bundling
    buildTimeVideosData = [];

} catch (error) {
    console.error("Error reading or processing liked_videos.json during build:", error);
    errorMessage = "Could not load video data during build. Filters might be unavailable.";
    // Assign default empty values if build fails
    totalItems = 0;
    uniqueYears = [];
    uniqueChannels = [];
}
// --- End Build-time Data Extraction ---


// --- Initial State from URL (Client will refine) ---
// We still need validLimits defined for the client script to use
const validLimits = [30, 60, 90];
// Basic check for initial limit to pass, client will validate more strictly
const requestUrl = new URL(Astro.request.url);
const urlParams = requestUrl.searchParams;
let initialLimit = parseInt(urlParams.get("limit") || validLimits[0].toString());
if (!validLimits.includes(initialLimit)) {
    initialLimit = validLimits[0];
}
// --- End Initial State ---

---

<BaseLayout
    title={title}
    description={description}
    permalink={permalink ?? "/"}
    current="bookmarks"
>
    <div class="container">
        <h1 class="!mb-4">My Entire YouTube History in {totalItems > 0 ? `${totalItems} ` : ''} Videos</h1>
        <p class="!m-0">On AI Research, Software, and Digital Media</p>
        <hr />

        <!-- Error Message Display -->
        {errorMessage && (
            <div class="my-4 p-4 bg-red-100 border border-red-400 text-red-700 rounded">
                <p><strong>Build Error:</strong> {errorMessage}</p>
            </div>
        )}

        <!-- Filter Controls (Render based on build-time data) -->
        <div
            class="filter-controls flex flex-row flex-wrap justify-center gap-x-4 gap-y-2 my-4 sm:justify-center sm:items-center"
        >
            <div class="flex items-center gap-x-2 justify-between">
                <select
                    id="year-select"
                    class="border rounded px-2 py-1 text-sm bg-[var(--background-body)] text-[var(--text-main)] border-gray-300 dark:border-gray-600 w-full"
                    disabled={uniqueYears.length === 0}
                >
                    <option value="all">All Years</option>
                    {
                        uniqueYears.map((year) => (
                            <option value={year}>{year}</option>
                        ))
                    }
                </select>
            </div>
            <div class="flex items-center gap-x-2 justify-between">
                <select
                    id="channel-select"
                    class="border rounded px-2 py-1 text-sm bg-[var(--background-body)] text-[var(--text-main)] border-gray-300 dark:border-gray-600 w-full"
                     disabled={uniqueChannels.length === 0}
                >
                    <option value="all">All Channels</option>
                    {
                        uniqueChannels.map((channel) => {
                            const maxLen = 15;
                            const displayTitle =
                                channel.title.length > maxLen
                                    ? channel.title.substring(0, maxLen) + "â€¦"
                                    : channel.title;
                            return (
                                <option
                                    value={channel.id}
                                    title={channel.title}
                                >
                                    {displayTitle}
                                </option>
                            );
                        })
                    }
                </select>
            </div>
            <!-- Remove Filter Button (hidden by default) -->
            <button
                id="remove-filters-button"
                class="hidden text-sm hover:underline focus:outline-none flex justify-start items-center"
                disabled
            >
                <p class="text-sm text-[var(--primary-color)]">Clear Filters</p>
            </button>

            {/* Items per page selector */}
            <div class="pagination-limit flex items-center">
                <select
                    id="limit-select"
                    class="border rounded px-2 py-1 text-sm bg-[var(--background-body)]"
                    disabled={totalItems === 0}
                >
                    {validLimits.map((l) => (
                       <option value={l} selected={l === initialLimit}>{l}</option>
                    ))}
                </select>
                <p class="ml-2 text-sm whitespace-nowrap">per Page</p>
            </div>
        </div>

        <!-- Video Grid -->
        <div
            id="video-grid-container"
            class="grid grid-cols-[repeat(auto-fill,minmax(200px,1fr))] gap-6 mt-8 mb-8 min-h-[200px]"
        >
            {/* Initial Loading Indicator */}
            <div id="loading-indicator" class="col-span-full flex flex-col items-center justify-center min-h-[200px]">
                 <div class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-[var(--primary-color)]"></div>
                 <p class="mt-4 text-center">Loading Videos...</p>
                 <p id="error-message" class="mt-2 text-red-600 text-sm text-center hidden"></p>
            </div>
            {/* Content will be injected here by JS */}
        </div>


        <!-- Pagination Controls -->
        { totalItems > 0 ? ( // Only show pagination structure if items exist (based on build count)
                <div class="pagination-controls flex flex-row flex-nowrap justify-center items-center gap-2 sm:gap-4 my-6">
                    {/* Navigation buttons and page info */}
                        <a
                            id="prev-button"
                            href="#"
                            class="mr-2 nav-button disabled text-[color:var(--text-secondary)] font-sans text-sm font-bold no-underline transition-all duration-200 ease-in-out shadow-[inset_0_-0.12em_0_var(--primary-color)] hover:shadow-[inset_0_-1.5em_0_var(--primary-color)] hover:text-white aria-disabled:opacity-50 aria-disabled:cursor-not-allowed aria-disabled:pointer-events-none aria-disabled:shadow-[inset_0_-0.12em_0_var(--text-secondary)] aria-disabled:hover:text-[color:var(--text-secondary)]"
                            aria-disabled="true"
                        >
                            &laquo; Prev
                        </a>
                        <!-- New Page Select Dropdown -->
                        <div class="page-select-container flex items-center text-sm px-1 whitespace-nowrap">
                             <span class="mr-1">Page</span>
                             <select
                                id="page-select"
                                class="p-1 text-sm bg-[var(--background-body)] text-[var(--text-main)] text-center"
                                disabled
                                aria-label="Select page number"
                            >
                                <option value="1">1</option> {/* Placeholder */}
                            </select>
                            <span id="page-total-span" class="ml-2">of ?</span>
                        </div>
                        <a
                            id="next-button"
                            href="#"
                            class="ml-2 nav-button disabled text-[color:var(--text-secondary)] font-sans text-sm font-bold no-underline transition-all duration-200 ease-in-out shadow-[inset_0_-0.12em_0_var(--primary-color)] hover:shadow-[inset_0_-1.5em_0_var(--primary-color)] hover:text-white aria-disabled:opacity-50 aria-disabled:cursor-not-allowed aria-disabled:pointer-events-none aria-disabled:shadow-[inset_0_-0.12em_0_var(--text-secondary)] aria-disabled:hover:text-[color:var(--text-secondary)]"
                            aria-disabled="true"
                        >
                            Next &raquo;
                        </a>
                </div>
            ) : errorMessage ? null : (
                 <div class="text-center text-gray-500 my-6">No videos found.</div>
            )
        }
        <hr />
        <p class="footnote text-sm">
            This video playlist is automatically updated daily and synced with
            my YouTube account â€”<a href="https://www.youtube.com/@alhrkn/playlists" target="_blank" rel="noopener noreferrer">check it out</a> for more playlists!
        </p>
    </div>
</BaseLayout>

<script
    define:vars={{
        // Pass only necessary data, NOT the full video list
        initialTotalItems: totalItems,
        validLimits,
        // Keep build-time lists for initial render & validation
        initialUniqueYears: uniqueYears,
        initialUniqueChannels: uniqueChannels,
        jsonUrl: '/os-bookmarks/liked_videos.json' // URL to fetch
    }}
>
    // Get elements
    const gridContainer = document.getElementById("video-grid-container");
    const prevButton = document.getElementById("prev-button");
    const nextButton = document.getElementById("next-button");
    const pageSelect = document.getElementById("page-select"); // New page dropdown
    const pageTotalSpan = document.getElementById("page-total-span"); // Span for \"of Y\"
    const limitSelect = document.getElementById("limit-select");
    const yearSelect = document.getElementById("year-select");
    const channelSelect = document.getElementById("channel-select");
    const removeFiltersButton = document.getElementById("remove-filters-button");
    const loadingIndicator = document.getElementById("loading-indicator");
    const errorMessageElement = document.getElementById("error-message"); // Added error message display

    // State variables
    let allVideos = []; // Will be populated by fetch
    let isDataLoading = true;
    let currentPage = 1;
    let itemsPerPage = validLimits[0];
    let totalPages = 1;
    let selectedYear = "all";
    let selectedChannelId = "all";
    // Keep track of build-time filters for validation/initial state
    const uniqueYearsFromBuild = initialUniqueYears.map(y => y);
    const uniqueChannelsFromBuild = initialUniqueChannels.map(c => ({ ...c }));


    function updateUrl() {
        const url = new URL(window.location.href);
        url.searchParams.set("page", currentPage.toString());
        url.searchParams.set("limit", itemsPerPage.toString());
        url.searchParams.set("year", selectedYear);
        url.searchParams.set("channel", selectedChannelId);
        // Use pushState to change URL without reloading
        history.pushState({}, "", url.toString());
    }

    // --- Functions to Update Dropdown Options ---

    function updateYearOptions() {
        if (!yearSelect || allVideos.length === 0) return;

        // Determine available years based on the *selected channel*
        const videosForSelectedChannel = selectedChannelId === "all"
            ? allVideos
            : allVideos.filter(v => v.video_owner_channel_id === selectedChannelId);

        const availableYears = [
            ...new Set(videosForSelectedChannel.map((v) => v.published_at?.substring(0, 4)).filter(Boolean))
        ].sort((a, b) => parseInt(b) - parseInt(a)); // Sort descending

        // Preserve current selection if still valid
        const currentSelectedYearIsValid = availableYears.includes(selectedYear);
        if (!currentSelectedYearIsValid && selectedYear !== "all") {
            // If the current selection is no longer valid due to the channel filter,
            // we don't reset it here, as the user might be switching *between* filters.
            // The main filtering logic in renderPage will handle showing "no results".
            // We just ensure the option is visually available if possible.
        }

        // Update options
        let optionsHtml = '<option value="all">All Years</option>';
        availableYears.forEach(year => {
            optionsHtml += `<option value="${year}" ${year === selectedYear ? 'selected' : ''}>${year}</option>`;
        });

        // Add the currently selected year back if it was filtered out, but keep it selected
        // This prevents the dropdown from visually resetting while the user is actively filtering
        if (selectedYear !== "all" && !availableYears.includes(selectedYear)) {
             optionsHtml += `<option value="${selectedYear}" selected style="display: none;">${selectedYear} (filtered)</option>`; // Add hidden option
        }


        yearSelect.innerHTML = optionsHtml;
        yearSelect.value = selectedYear; // Ensure the value property matches state
        yearSelect.disabled = availableYears.length === 0 && selectedChannelId === "all"; // Disable only if truly no options
    }


     function updateChannelOptions() {
        if (!channelSelect || allVideos.length === 0) return;

        // Determine available channels based on the *selected year*
        const videosForSelectedYear = selectedYear === "all"
            ? allVideos
            : allVideos.filter(v => v.published_at?.startsWith(selectedYear));

        const availableChannelsMap = new Map();
        videosForSelectedYear.forEach((v) => {
            if (v.video_owner_channel_id && !availableChannelsMap.has(v.video_owner_channel_id)) {
                availableChannelsMap.set(
                    v.video_owner_channel_id,
                    v.video_owner_channel_title || 'Unknown Channel'
                );
            }
        });

        const availableChannels = Array.from(availableChannelsMap.entries())
            .map(([id, title]) => ({ id, title }))
            .sort((a, b) => a.title.localeCompare(b.title)); // Sort alphabetically

        // Preserve current selection if still valid
        const currentSelectedChannelIsValid = availableChannels.some(c => c.id === selectedChannelId);
         if (!currentSelectedChannelIsValid && selectedChannelId !== "all") {
             // Similar logic as for years - don't reset automatically
         }

        // Update options
        let optionsHtml = '<option value="all">All Channels</option>';
        const maxLen = 15; // Title truncation length
        availableChannels.forEach(channel => {
            const displayTitle = channel.title.length > maxLen
                ? channel.title.substring(0, maxLen) + "â€¦"
                : channel.title;
            optionsHtml += `<option value="${channel.id}" title="${channel.title}" ${channel.id === selectedChannelId ? 'selected' : ''}>${displayTitle}</option>`;
        });

         // Add the currently selected channel back if it was filtered out, but keep it selected
        if (selectedChannelId !== "all" && !availableChannels.some(c => c.id === selectedChannelId)) {
             // Find the original title from build-time data or fallback
             const originalChannel = uniqueChannelsFromBuild.find(c => c.id === selectedChannelId);
             const title = originalChannel ? originalChannel.title : 'Unknown Channel (filtered)';
             const displayTitle = title.length > maxLen ? title.substring(0, maxLen) + "â€¦" : title;
             optionsHtml += `<option value="${selectedChannelId}" title="${title}" selected style="display: none;">${displayTitle} (filtered)</option>`; // Add hidden option
        }


        channelSelect.innerHTML = optionsHtml;
        channelSelect.value = selectedChannelId; // Ensure the value property matches state
        channelSelect.disabled = availableChannels.length === 0 && selectedYear === "all"; // Disable only if truly no options
    }


    // --- End Functions to Update Dropdown Options ---

    function renderPage() {
         // console.log("Render page called. Loading:", isDataLoading, "Data length:", allVideos.length);

        if (
            !gridContainer || !pageSelect || !pageTotalSpan || !prevButton || !nextButton ||
            !limitSelect || !yearSelect || !channelSelect || !loadingIndicator
        ) return;

        // Show loading indicator if data isn't ready
        loadingIndicator.classList.toggle("hidden", !isDataLoading);
        gridContainer.classList.toggle("grid", !isDataLoading); // Ensure grid is applied only when loaded


        if (isDataLoading) {
            // If still loading, ensure pagination/filters are disabled (or use build-time defaults)
            pageSelect.disabled = true;
            pageTotalSpan.textContent = "of ?";
            prevButton.classList.add("disabled");
            prevButton.setAttribute("aria-disabled", "true");
            nextButton.classList.add("disabled");
            nextButton.setAttribute("aria-disabled", "true");
            limitSelect.disabled = true;
            // Keep build-time options visible but disabled during initial load
            yearSelect.disabled = true;
            channelSelect.disabled = true;
            if (removeFiltersButton) removeFiltersButton.disabled = true;
            gridContainer.innerHTML = ''; // Clear any previous grid content
            gridContainer.appendChild(loadingIndicator); // Make sure indicator is inside grid area
            return; // Don't proceed further until data is loaded
        }

        // --- Data Loaded ---
        // Enable core controls now that data is loaded
        limitSelect.disabled = false;

        // --- Update Dropdown Options BASED on current state ---
        updateYearOptions(); // Update year options based on selectedChannelId
        updateChannelOptions(); // Update channel options based on selectedYear
        // --- End Update Dropdown Options ---

        // --- Apply Filters ---
        let filteredVideos = allVideos;
        if (selectedYear !== "all") {
            // Ensure filtering uses optional chaining for safety if published_at is missing
            filteredVideos = filteredVideos.filter((video) =>
                video.published_at?.startsWith(selectedYear),
            );
        }
        if (selectedChannelId !== "all") {
            filteredVideos = filteredVideos.filter(
                (video) => video.video_owner_channel_id === selectedChannelId,
            );
        }
        // --- End Apply Filters ---

        const currentTotalItems = filteredVideos.length;
        totalPages = Math.ceil(currentTotalItems / itemsPerPage);
        // Ensure currentPage is valid after filtering
        if (totalPages > 0 && currentPage > totalPages) {
            currentPage = totalPages; // Go to last page if current page is too high
        } else if (totalPages === 0) {
            currentPage = 1; // Reset to page 1 if no results
        }
        currentPage = Math.max(1, currentPage); // Ensure it's at least 1


        const offset = (currentPage - 1) * itemsPerPage;
        const videosToShow = filteredVideos.slice(offset, offset + itemsPerPage);
        const maxLength = 40; // Max characters for title

        // Generate grid HTML or "No results" message
        if (videosToShow.length > 0) {
            gridContainer.innerHTML = videosToShow
                .map((video) => {
                    // Ensure title is a string, provide fallback
                    const title = typeof video.title === 'string' ? video.title : 'Untitled Video';
                    let displayTitle = title;
                    if (displayTitle.length > maxLength) {
                        const lastSpace = displayTitle.lastIndexOf(" ", maxLength - 1);
                        displayTitle = (lastSpace > maxLength / 2)
                            ? displayTitle.substring(0, lastSpace) + "â€¦"
                            : displayTitle.substring(0, maxLength - 1) + "â€¦";
                    }

                    const imageUrl = video.thumbnail_url;
                    // Ensure imageUrl is a string and looks like a valid URL before using it in <img>
                    const isValidImageUrl = typeof imageUrl === 'string' && imageUrl.trim() !== '' && imageUrl.startsWith('http');
                    const imageHtml = isValidImageUrl
                            ? `<img src="${imageUrl}" alt="${title}" loading="lazy" class="w-full aspect-video object-cover block"/>`
                            : `<div class="w-full aspect-video bg-gray-200 dark:bg-gray-600 flex items-center justify-center"><span class="text-xs text-gray-500 dark:text-gray-400">No Thumbnail</span></div>`;

                    // Ensure url is a string, provide fallback
                     const videoUrl = typeof video.url === 'string' ? video.url : '#';

                    return `
                <a href="${videoUrl}" target="_blank" rel="noopener noreferrer" class="flex flex-col no-underline text-inherit rounded-lg overflow-hidden shadow-md hover:shadow-xl hover:-translate-y-1 transition duration-200 ease-in-out" title="${title}">
                    ${imageHtml}
                    <p class="px-3 pt-3 pb-4 text-sm m-0 leading-tight">${displayTitle}</p>
                </a>
            `;
                })
                .join("");
        } else {
            gridContainer.innerHTML = `
                <div class="col-span-full text-center py-10">
                    <p class="text-lg text-[color:var(--text-secondary)]">No videos match your filters.<br>${selectedYear !== 'all' || selectedChannelId !== 'all' ? 'Try adjusting or clearing filters.' : ''}</p>
                </div>`;
        }

        // --- Update Page Select Dropdown ---
        pageTotalSpan.textContent = `of ${totalPages > 0 ? totalPages : 1}`;
        // Populate dropdown options
        pageSelect.innerHTML = ''; // Clear previous options
        const maxOptionsToShow = 500; // Limit options for performance if totalPages is huge
        for (let i = 1; i <= Math.min(totalPages > 0 ? totalPages : 1, maxOptionsToShow); i++) { // Ensure loop runs even if totalPages is 0
            const option = document.createElement('option');
            option.value = i.toString();
            option.textContent = i.toString();
            pageSelect.appendChild(option);
        }
        if (totalPages > maxOptionsToShow) {
             const option = document.createElement('option');
             option.value = currentPage.toString(); // Ensure current is selectable if > max
             option.textContent = `${currentPage} (current)`;
             option.disabled = true; // Visually indicate it might be outside normal range
             pageSelect.appendChild(option);
             console.warn(`Page dropdown limited to first ${maxOptionsToShow} options due to large number of pages.`);
        }
        pageSelect.value = currentPage.toString();
        pageSelect.disabled = totalPages <= 1; // Re-evaluate disable state
        // --- End Update Page Select ---

        // --- Show/Hide Remove Filters Button ---
        if (removeFiltersButton) {
            const filtersActive = selectedYear !== "all" || selectedChannelId !== "all";
            removeFiltersButton.classList.toggle("hidden", !filtersActive);
            removeFiltersButton.disabled = !filtersActive; // Also disable if not active
        }

        // Update button states
        const hasPrev = currentPage > 1 && totalPages > 0;
        const hasNext = currentPage < totalPages && totalPages > 0;

        prevButton.classList.toggle("disabled", !hasPrev);
        prevButton.setAttribute("aria-disabled", (!hasPrev).toString());

        nextButton.classList.toggle("disabled", !hasNext);
        nextButton.setAttribute("aria-disabled", (!hasNext).toString());

        // Ensure filter dropdowns correctly reflect state (value was set within updateXXXOptions)
        // yearSelect.value = selectedYear;
        // channelSelect.value = selectedChannelId;
    }

    function handleNavClick(event, newPage) {
        event.preventDefault();
        if (isDataLoading) return; // Don't navigate if data isn't loaded

        // Recalculate total pages based on current filters *before* checking bounds
        let currentFilteredVideos = allVideos;
        if (selectedYear !== "all") {
             currentFilteredVideos = currentFilteredVideos.filter(v => v.published_at?.startsWith(selectedYear));
        }
        if (selectedChannelId !== "all") {
            currentFilteredVideos = currentFilteredVideos.filter(v => v.video_owner_channel_id === selectedChannelId);
        }
        const currentTotalItems = currentFilteredVideos.length;
        const currentTotalPages = Math.ceil(currentTotalItems / itemsPerPage);


        if (newPage < 1 || newPage > (currentTotalPages > 0 ? currentTotalPages : 1)) return;

        currentPage = newPage;
        updateUrl();
        renderPage();
    }

    async function initializeAndFetchData() {
        // console.log("Initializing and fetching data...");
        isDataLoading = true;
        if (errorMessageElement) errorMessageElement.classList.add('hidden'); // Hide previous errors
        renderPage(); // Show initial loading state (with build-time dropdowns disabled)

        try {
            // console.log(`Fetching from: ${jsonUrl}`);
            const response = await fetch(jsonUrl);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
             // console.log(`Fetched ${data.length} videos.`);

            if (!Array.isArray(data)) {
                 throw new Error("Fetched data is not an array.");
            }

            // --- Data Validation (Optional but Recommended) ---
            // Simple check on the first item if available
            if (data.length > 0) {
                 const firstItem = data[0];
                 if (typeof firstItem.title === 'undefined' || typeof firstItem.url === 'undefined') {
                     console.warn("Fetched data structure seems incorrect. Missing 'title' or 'url' in the first item.");
                     // Potentially throw an error or handle differently
                 }
            }
             // --- End Validation ---

            // Filter out videos titled "Private Video" immediately after fetch
            allVideos = data.filter(video => video.title !== "Private video");

            isDataLoading = false; // Mark loading as complete BEFORE setting state

            // --- Set Initial State from URL AFTER data load ---
            const urlParams = new URLSearchParams(window.location.search);
            const initialPage = parseInt(urlParams.get("page") || "1");
            const initialLimit = parseInt(urlParams.get("limit") || validLimits[0].toString());
            const initialYear = urlParams.get("year") || "all";
            const initialChannel = urlParams.get("channel") || "all";

            // Set Limit
            itemsPerPage = validLimits.includes(initialLimit) ? initialLimit : validLimits[0];
            limitSelect.value = itemsPerPage.toString();

            // Set Year Filter (Validate against potentially available years AFTER fetch)
            // Note: Validation against build-time list is less useful now, but kept for consistency
            const allFetchedYears = [...new Set(allVideos.map(v => v.published_at?.substring(0, 4)).filter(Boolean))];
            selectedYear = (initialYear === "all" || allFetchedYears.includes(initialYear)) ? initialYear : "all";
            // yearSelect.value will be set by updateYearOptions within renderPage

            // Set Channel Filter (Validate against potentially available channels AFTER fetch)
            const allFetchedChannelIds = ["all", ...new Set(allVideos.map(v => v.video_owner_channel_id).filter(Boolean))];
            selectedChannelId = allFetchedChannelIds.includes(initialChannel) ? initialChannel : "all";
            // channelSelect.value will be set by updateChannelOptions within renderPage

            // Calculate initial totalPages based on the potentially filtered data (before setting page)
            let initialFilteredVideos = allVideos;
            if (selectedYear !== "all") {
                initialFilteredVideos = initialFilteredVideos.filter(v => v.published_at?.startsWith(selectedYear));
            }
            if (selectedChannelId !== "all") {
                initialFilteredVideos = initialFilteredVideos.filter(v => v.video_owner_channel_id === selectedChannelId);
            }
            const initialFilteredTotalItems = initialFilteredVideos.length;
            totalPages = Math.ceil(initialFilteredTotalItems / itemsPerPage);

            // Set Current Page (Validate against calculated total pages)
            currentPage = (initialPage >= 1 && initialPage <= (totalPages > 0 ? totalPages : 1)) ? initialPage : 1;

            // --- End Set Initial State ---

            renderPage(); // First render with actual data and updated dropdowns
            updateUrl(); // Sync URL
            setupEventListeners(); // Add listeners now that data is ready

        } catch (error) {
            console.error("Failed to fetch or process video data:", error);
            isDataLoading = false; // Stop loading state
             if (loadingIndicator) loadingIndicator.classList.add('hidden'); // Hide spinner
             if (errorMessageElement) {
                errorMessageElement.textContent = `Error loading videos: ${error.message}. Please try refreshing.`;
                errorMessageElement.classList.remove('hidden'); // Show error message
             }
            // Optionally disable controls or show a persistent error message in the grid
            gridContainer.innerHTML = `<div class="col-span-full text-center py-10 text-red-600">Failed to load videos.</div>`;
             // Disable controls on error - Keep build-time dropdowns visible but disabled
             if (limitSelect) limitSelect.disabled = true;
             if (yearSelect) yearSelect.disabled = true; // Keep disabled
             if (channelSelect) channelSelect.disabled = true; // Keep disabled
             if (removeFiltersButton) removeFiltersButton.disabled = true;
             if (prevButton) prevButton.classList.add("disabled"); prevButton.setAttribute("aria-disabled", "true");
             if (nextButton) nextButton.classList.add("disabled"); nextButton.setAttribute("aria-disabled", "true");
             if (pageSelect) pageSelect.disabled = true;
             if (pageTotalSpan) pageTotalSpan.textContent = "of ?";
        }
    }


    function setupEventListeners() {
        // console.log("Setting up event listeners...");
        if (!limitSelect || !yearSelect || !channelSelect || !prevButton || !nextButton || !pageSelect) return;

        // Helper to replace listeners (avoids duplicates on HMR/popstate)
        const replaceListener = (element, eventType, newHandler) => {
            if (element._handler) {
                element.removeEventListener(eventType, element._handler);
            }
            element.addEventListener(eventType, newHandler);
            element._handler = newHandler;
        };

        const handleYearChange = (event) => {
            const target = event.target;
            if (target && "value" in target) {
                selectedYear = target.value;
                currentPage = 1; // Reset page when filter changes
                updateUrl();
                renderPage(); // Re-render which includes updating channel options
            }
        };
        replaceListener(yearSelect, "change", handleYearChange);

        const handleChannelChange = (event) => {
            const target = event.target;
            if (target && "value" in target) {
                selectedChannelId = target.value;
                currentPage = 1; // Reset page when filter changes
                updateUrl();
                renderPage(); // Re-render which includes updating year options
            }
        };
        replaceListener(channelSelect, "change", handleChannelChange);

        const handleLimitChange = (event) => {
            const target = event.target;
            if (target && "value" in target) {
                const newLimit = parseInt(target.value);
                if (validLimits.includes(newLimit)) {
                    itemsPerPage = newLimit;
                    currentPage = 1; // Reset page when limit changes
                    updateUrl();
                    renderPage();
                }
            }
        };
        replaceListener(limitSelect, "change", handleLimitChange);

        const handlePrevClick = (event) => handleNavClick(event, currentPage - 1);
        replaceListener(prevButton, "click", handlePrevClick);

        const handleNextClick = (event) => handleNavClick(event, currentPage + 1);
        replaceListener(nextButton, "click", handleNextClick);

        const handleRemoveFilters = (event) => {
            event.preventDefault();
            selectedYear = "all";
            selectedChannelId = "all";
            currentPage = 1;
            updateUrl();
            renderPage(); // Re-render which includes updating both dropdowns to full lists
        };
        if (removeFiltersButton) {
            replaceListener(removeFiltersButton, "click", handleRemoveFilters);
        }

        // --- Page Select Listener ---
         const handlePageSelectChange = (event) => {
            const target = event.target;
             if (target && "value" in target) {
                const newPage = parseInt(target.value);
                 // Check against totalPages which is updated in renderPage
                 if (!isNaN(newPage) && newPage >= 1 && newPage <= (totalPages > 0 ? totalPages : 1)) {
                     currentPage = newPage;
                     updateUrl();
                     renderPage();
                 }
            }
        };
        replaceListener(pageSelect, "change", handlePageSelectChange);
        // --- End Page Select Listener ---

        // Handle browser back/forward buttons
        if (!window._popstateHandledVideos) {
            window.addEventListener("popstate", () => {
                 // console.log("Popstate triggered, re-initializing from URL.");
                 // Re-read URL and set state, then render (no re-fetch needed)
                 const urlParams = new URLSearchParams(window.location.search);
                 const popPage = parseInt(urlParams.get("page") || "1");
                 const popLimit = parseInt(urlParams.get("limit") || validLimits[0].toString());
                 const popYear = urlParams.get("year") || "all";
                 const popChannel = urlParams.get("channel") || "all";

                 // Set state directly from URL
                 itemsPerPage = validLimits.includes(popLimit) ? popLimit : validLimits[0];
                 // Validate filters against the currently loaded 'allVideos' data
                 const allFetchedYears = ["all", ...new Set(allVideos.map(v => v.published_at?.substring(0, 4)).filter(Boolean))];
                 selectedYear = allFetchedYears.includes(popYear) ? popYear : "all";

                 const allFetchedChannelIds = ["all", ...new Set(allVideos.map(v => v.video_owner_channel_id).filter(Boolean))];
                 selectedChannelId = allFetchedChannelIds.includes(popChannel) ? popChannel : "all";

                 // Recalculate totalPages based on pop state filters before setting page
                 let popFilteredVideos = allVideos;
                 if (selectedYear !== "all") {
                    popFilteredVideos = popFilteredVideos.filter(v => v.published_at?.startsWith(selectedYear));
                 }
                 if (selectedChannelId !== "all") {
                     popFilteredVideos = popFilteredVideos.filter(v => v.video_owner_channel_id === selectedChannelId);
                 }
                 const popFilteredTotalItems = popFilteredVideos.length;
                 const popTotalPages = Math.ceil(popFilteredTotalItems / itemsPerPage);

                 currentPage = (popPage >= 1 && popPage <= (popTotalPages > 0 ? popTotalPages : 1)) ? popPage : 1;


                 if (!isDataLoading) { // Only render if data is actually loaded
                    renderPage();
                 } else {
                     // If popstate happens before initial load finishes,
                     // the initializeAndFetchData function will handle the URL params correctly when it finishes.
                     console.log("Popstate occurred before initial data load finished.");
                 }

            });
            window._popstateHandledVideos = true;
        }
    }

    // Start the process
    initializeAndFetchData();

</script>

<style is:global>
    /* Thin scrollbar for #page-select in Webkit browsers */
    #page-select::-webkit-scrollbar {
      width: 5px;
    }

    #page-select::-webkit-scrollbar-track {
      background: transparent;
    }

    #page-select::-webkit-scrollbar-thumb {
      background-color: var(--text-secondary);
      border-radius: 10px;
      border: none;
    }

    /* Thin scrollbar for #page-select in Firefox */
    #page-select {
      scrollbar-width: thin;
      scrollbar-color: var(--text-secondary) transparent;
    }
</style>
