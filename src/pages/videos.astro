---
import BaseLayout from "../layouts/BaseLayout.astro";
// import { readFile } from 'node:fs/promises'; // Remove Node.js fs
// import path from 'node:path'; // Remove Node.js path
import { createClient } from "@supabase/supabase-js";

// Define the expected structure of a video object
interface Video {
    title: string;
    thumbnail_url: string;
    url: string;
    video_owner_channel_id: string;
    video_owner_channel_title: string;
    published_at: string; // Supabase typically returns TIMESTAMPTZ as ISO string
}

const page_title = "Videos - Al Harkan"; // Renamed to avoid conflict with Video.title
const description =
    "Videos Curation on AI Research, Software, and Digital Media";
const permalink = Astro.site?.href ? `${Astro.site.href}videos` : "/videos";

// Initialize Supabase client
const supabaseUrl = import.meta.env.SUPABASE_URL;
const supabaseAnonKey = import.meta.env.SUPABASE_ANON_KEY;

let allVideosData: Video[] = [];
let totalItems = 0;
let uniqueYears: string[] = [];
let uniqueChannels: { id: string; title: string }[] = [];
let errorMessage: string | null = null;

if (!supabaseUrl || !supabaseAnonKey) {
    errorMessage = "Supabase URL or Anon Key is not set in environment variables.";
    console.warn(errorMessage);
}

const supabase = supabaseUrl && supabaseAnonKey ? createClient(supabaseUrl, supabaseAnonKey) : null;

async function getLikedVideosFromSupabase(): Promise<Video[]> {
    if (!supabase) {
        throw new Error("Supabase client not initialized.");
    }

    const CHUNK_SIZE = 1000; // Supabase default max limit
    let allData: Video[] = [];
    let offset = 0;
    let keepFetching = true;

    while (keepFetching) {
        const { data, error, count } = await supabase
            .from("liked_videos")
            .select("title, thumbnail_url, url, video_owner_channel_id, video_owner_channel_title, published_at", { count: 'exact' }) // Request count
            .order("published_at", { ascending: false })
            .range(offset, offset + CHUNK_SIZE - 1);

        if (error) {
            console.error("Error fetching liked videos from Supabase (chunk):", error);
            // Depending on desired behavior, you might throw the error or return partially fetched data.
            // For now, let's throw to indicate failure.
            throw error;
        }

        if (data) {
            const mappedData = data.map(item => ({
                title: item.title,
                thumbnail_url: item.thumbnail_url,
                url: item.url,
                video_owner_channel_id: item.video_owner_channel_id,
                video_owner_channel_title: item.video_owner_channel_title,
                published_at: item.published_at,
            }));
            allData = allData.concat(mappedData);
        }

        if (data && data.length < CHUNK_SIZE) {
            keepFetching = false; // Last chunk fetched
        } else if (!data || data.length === 0) {
            // This case handles if count was not exact or if something unexpected happened
            keepFetching = false; 
        } else {
            offset += CHUNK_SIZE;
        }

        // Safety break if count is available and we've fetched enough, though data.length check should suffice
        if (count !== null && allData.length >= count) {
            keepFetching = false;
        }
    }
    console.log(`Fetched a total of ${allData.length} videos from Supabase.`);
    return allData;
}

if (supabase) {
    try {
        const rawVideos = await getLikedVideosFromSupabase();
        // Filter out "Private video" entries
        allVideosData = rawVideos.filter((video: Video) => video.title !== "Private video" && video.title !== null);

        totalItems = allVideosData.length;

        if (totalItems > 0) {
            uniqueYears = [
                ...new Set(allVideosData.map((v) => v.published_at?.substring(0, 4)).filter(Boolean)),
            ].sort((a, b) => parseInt(b) - parseInt(a));

            const uniqueChannelsMap = new Map<string, string>();
            allVideosData.forEach((v) => {
                if (v.video_owner_channel_id && !uniqueChannelsMap.has(v.video_owner_channel_id)) {
                    uniqueChannelsMap.set(
                        v.video_owner_channel_id,
                        v.video_owner_channel_title || 'Unknown Channel',
                    );
                }
            });
            uniqueChannels = Array.from(uniqueChannelsMap.entries())
                .map(([id, title]) => ({ id, title }))
                .sort((a, b) => a.title.localeCompare(b.title));
        }
    } catch (error) {
        console.error("Error fetching or processing liked_videos from Supabase:", error);
        if (error instanceof Error) {
            errorMessage = `Could not load video data: ${error.message}`;
        } else {
            errorMessage = "Could not load video data: An unknown error occurred.";
        }
        // Assign default empty values if fetch fails
        totalItems = 0;
        uniqueYears = [];
        uniqueChannels = [];
        allVideosData = []; // Ensure it's empty on error
    }
} else if (!errorMessage) { // If supabase is null and no specific env var message
    errorMessage = "Supabase client could not be initialized. Videos cannot be loaded.";
}


// --- Initial State from URL (Client will refine) ---
const validLimits = [30, 60, 90];
const requestUrl = new URL(Astro.request.url);
const urlParams = requestUrl.searchParams;
let initialLimit = parseInt(urlParams.get("limit") || validLimits[0].toString());
if (!validLimits.includes(initialLimit)) {
    initialLimit = validLimits[0];
}
// --- End Initial State ---

---

<BaseLayout
    title={page_title}
    description={description}
    permalink={permalink ?? "/"}
    current="videos"
>
    <div class="container">
        <h1 class="!mb-4">My Entire YouTube History in {totalItems > 0 ? `${totalItems} ` : ''} Videos</h1>
        <p class="!m-0">On AI Research, Software, and Digital Media</p>
        <hr />

        <!-- Error Message Display -->
        {errorMessage && (
            <div class="my-4 p-4 bg-red-100 border border-red-400 text-red-700 rounded">
                <p><strong>Build Error:</strong> {errorMessage}</p>
            </div>
        )}

        <!-- Filter Controls (Render based on build-time data) -->
        <div
            class="filter-controls flex flex-row flex-wrap justify-center gap-x-4 gap-y-2 my-4 sm:justify-center sm:items-center"
        >
            <div class="flex items-center gap-x-2 justify-between">
                <select
                    id="year-select"
                    class="border rounded px-2 py-1 text-sm bg-[var(--background-body)] text-[var(--text-main)] border-gray-300 dark:border-gray-600 w-full"
                    disabled={uniqueYears.length === 0}
                >
                    <option value="all">All Years</option>
                    {
                        uniqueYears.map((year) => (
                            <option value={year}>{year}</option>
                        ))
                    }
                </select>
            </div>
            <div class="flex items-center gap-x-2 justify-between">
                <select
                    id="channel-select"
                    class="border rounded px-2 py-1 text-sm bg-[var(--background-body)] text-[var(--text-main)] border-gray-300 dark:border-gray-600 w-full"
                     disabled={uniqueChannels.length === 0}
                >
                    <option value="all">All Channels</option>
                    {
                        uniqueChannels.map((channel) => {
                            const maxLen = 15;
                            const displayTitle =
                                channel.title.length > maxLen
                                    ? channel.title.substring(0, maxLen) + "â€¦"
                                    : channel.title;
                            return (
                                <option
                                    value={channel.id}
                                    title={channel.title}
                                >
                                    {displayTitle}
                                </option>
                            );
                        })
                    }
                </select>
            </div>
            <!-- Remove Filter Button (hidden by default) -->
            <button
                id="remove-filters-button"
                class="hidden text-sm hover:underline focus:outline-none flex justify-start items-center"
                disabled
            >
                <p class="text-sm text-[var(--primary-color)]">Clear Filters</p>
            </button>

            {/* Items per page selector */}
            <div class="pagination-limit flex items-center">
                <select
                    id="limit-select"
                    class="border rounded px-2 py-1 text-sm bg-[var(--background-body)]"
                    disabled={totalItems === 0}
                >
                    {validLimits.map((l) => (
                       <option value={l} selected={l === initialLimit}>{l}</option>
                    ))}
                </select>
                <p class="ml-2 text-sm whitespace-nowrap">per Page</p>
            </div>
        </div>

        <!-- Video Grid -->
        <div
            id="video-grid-container"
            class="grid grid-cols-[repeat(auto-fill,minmax(200px,1fr))] gap-6 mt-8 mb-8 min-h-[200px]"
        >
            {/* Initial Loading Indicator */}
            <div id="loading-indicator" class="col-span-full flex flex-col items-center justify-center min-h-[200px]">
                 <div class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-[var(--primary-color)]"></div>
                 <p class="mt-4 text-center">Loading Videos...</p>
                 <p id="error-message" class="mt-2 text-red-600 text-sm text-center hidden"></p>
            </div>
            {/* Content will be injected here by JS */}
        </div>


        <!-- Pagination Controls -->
        { totalItems > 0 ? ( // Only show pagination structure if items exist (based on build count)
                <div class="pagination-controls flex flex-row flex-nowrap justify-center items-center gap-2 sm:gap-4 my-6">
                    {/* Navigation buttons and page info */}
                        <a
                            id="prev-button"
                            href="#"
                            class="mr-2 nav-button disabled text-[color:var(--text-secondary)] font-sans text-sm font-bold no-underline transition-all duration-200 ease-in-out shadow-[inset_0_-0.12em_0_var(--primary-color)] hover:shadow-[inset_0_-1.5em_0_var(--primary-color)] hover:text-white aria-disabled:opacity-50 aria-disabled:cursor-not-allowed aria-disabled:pointer-events-none aria-disabled:shadow-[inset_0_-0.12em_0_var(--text-secondary)] aria-disabled:hover:text-[color:var(--text-secondary)]"
                            aria-disabled="true"
                        >
                            Prev
                        </a>
                        <!-- New Page Select Dropdown -->
                        <div class="page-select-container flex items-center text-sm px-1 whitespace-nowrap">
                             <span class="mr-1">Page</span>
                             <select
                                id="page-select"
                                class="p-1 text-sm bg-[var(--background-body)] text-[var(--text-main)] text-center"
                                disabled
                                aria-label="Select page number"
                            >
                                <option value="1">1</option> {/* Placeholder */}
                            </select>
                            <span id="page-total-span" class="ml-2">of ?</span>
                        </div>
                        <a
                            id="next-button"
                            href="#"
                            class="ml-2 nav-button disabled text-[color:var(--text-secondary)] font-sans text-sm font-bold no-underline transition-all duration-200 ease-in-out shadow-[inset_0_-0.12em_0_var(--primary-color)] hover:shadow-[inset_0_-1.5em_0_var(--primary-color)] hover:text-white aria-disabled:opacity-50 aria-disabled:cursor-not-allowed aria-disabled:pointer-events-none aria-disabled:shadow-[inset_0_-0.12em_0_var(--text-secondary)] aria-disabled:hover:text-[color:var(--text-secondary)]"
                            aria-disabled="true"
                        >
                            Next
                        </a>
                </div>
            ) : errorMessage ? null : (
                 <div class="text-center text-gray-500 my-6">No videos found.</div>
            )
        }
        <hr />
        <p class="footnote text-sm">
            This video playlist is automatically updated daily and synced with
            my YouTube account â€”<a href="https://www.youtube.com/@alhrkn/playlists" target="_blank" rel="noopener noreferrer">check it out</a> for more playlists!
        </p>
    </div>
</BaseLayout>

<script
    define:vars={{
        // Pass the full video dataset fetched from Supabase
        allVideosData: allVideosData,
        initialTotalItems: totalItems, // Still useful for initial display before client hydration
        initialUniqueYears: uniqueYears, // Still useful for initial filter population
        initialUniqueChannels: uniqueChannels, // Still useful for initial filter population
        validLimits,
        // jsonUrl: '/os-bookmarks/liked_videos.json' // Remove jsonUrl
        fetchErrorMessage: errorMessage // Pass any fetch error to the client
    }}
>
    // Get elements
    const gridContainer = document.getElementById("video-grid-container");
    const prevButton = document.getElementById("prev-button");
    const nextButton = document.getElementById("next-button");
    const pageSelect = document.getElementById("page-select"); // New page dropdown
    const pageTotalSpan = document.getElementById("page-total-span"); // Span for \"of Y\"
    const limitSelect = document.getElementById("limit-select");
    const yearSelect = document.getElementById("year-select");
    const channelSelect = document.getElementById("channel-select");
    const removeFiltersButton = document.getElementById("remove-filters-button");
    const loadingIndicator = document.getElementById("loading-indicator");
    const errorMessageElement = document.getElementById("error-message"); // Added error message display

    // State variables
    let allVideos = allVideosData; // Use data passed from Astro frontmatter
    let isDataLoading = false; // Data is pre-loaded by Astro
    let fetchErrorFromServer = fetchErrorMessage; // Get error message from server
    let currentPage = 1;
    let itemsPerPage = validLimits[0];
    let totalPages = 1;
    let selectedYear = "all";
    let selectedChannelId = "all";
    let isInitialLoad = true; // Track if this is initial page load
    
    // Keep track of build-time filters for validation/initial state
    const uniqueYearsFromBuild = initialUniqueYears.map(y => y);
    const uniqueChannelsFromBuild = initialUniqueChannels.map(c => ({ ...c }));

    // Add a debug log function that shows in console
    function debugLog(...args) {
        console.log("[Videos Debug]", ...args);
    }
    
    // Flag to track if data is loaded
    let isDataLoaded = false;

    // Function to update URL in address bar
    function updateUrl(replace = false) {
        const url = new URL(window.location.href);
        url.searchParams.set("page", currentPage.toString());
        url.searchParams.set("limit", itemsPerPage.toString());
        url.searchParams.set("year", selectedYear);
        url.searchParams.set("channel", selectedChannelId);
        
        // Create state object with current parameters
        const state = {
            page: currentPage,
            limit: itemsPerPage,
            year: selectedYear,
            channel: selectedChannelId
        };
        
        console.log(`${replace ? "Replacing" : "Pushing"} URL:`, url.toString());
        
        if (replace || isInitialLoad) {
            // Use replaceState during initialization or when explicitly requested
            history.replaceState(state, "", url.toString());
            isInitialLoad = false;
        } else {
            // Use pushState for user-initiated changes to create history entries
            history.pushState(state, "", url.toString());
        }
    }

    function renderPage() {
        console.log("Rendering page with state:", {
            loading: isDataLoading,
            page: currentPage,
            limit: itemsPerPage,
            year: selectedYear,
            channel: selectedChannelId,
            videosCount: allVideos?.length || 0
        });

        if (
            !gridContainer || !pageSelect || !pageTotalSpan || !prevButton || !nextButton ||
            !limitSelect || !yearSelect || !channelSelect || !loadingIndicator
        ) {
            console.error("Missing required DOM elements for rendering");
            return;
        }

        // Show loading indicator if data isn't ready
        if (loadingIndicator) {
            loadingIndicator.classList.toggle("hidden", !isDataLoading);
        }
        if (gridContainer) {
            gridContainer.classList.toggle("grid", !isDataLoading); // Ensure grid is applied only when loaded
        }

        if (isDataLoading) {
            // If still loading, ensure pagination/filters are disabled
            if (pageSelect) pageSelect.disabled = true;
            if (pageTotalSpan) pageTotalSpan.textContent = "of ?";
            if (prevButton) {
                prevButton.classList.add("disabled");
                prevButton.setAttribute("aria-disabled", "true");
            }
            if (nextButton) {
                nextButton.classList.add("disabled");
                nextButton.setAttribute("aria-disabled", "true");
            }
            if (limitSelect) limitSelect.disabled = true;
            // Keep build-time options visible but disabled during initial load
            if (yearSelect) yearSelect.disabled = true;
            if (channelSelect) channelSelect.disabled = true;
            if (removeFiltersButton) removeFiltersButton.disabled = true;
            
            // Make sure loading indicator is visible
            if (gridContainer && loadingIndicator) {
                if (!gridContainer.contains(loadingIndicator)) {
                    gridContainer.innerHTML = ''; // Clear any previous grid content
                    gridContainer.appendChild(loadingIndicator); // Make sure indicator is inside grid area
                }
            }
            return; // Don't proceed further until data is loaded
        }

        // --- Data Loaded ---
        // Handle case where we don't have videos
        if (!allVideos || allVideos.length === 0) {
            console.log("No videos available to render.");
            gridContainer.innerHTML = `
                <div class="col-span-full text-center py-10">
                    <p class="text-lg text-[color:var(--text-secondary)]">No videos available.</p>
                </div>`;
            return;
        }

        // Enable core controls now that data is loaded
        if (limitSelect) limitSelect.disabled = false;
        if (yearSelect) yearSelect.disabled = false;
        if (channelSelect) channelSelect.disabled = false;

        // --- Update Dropdown Options BASED on current state ---
        try {
            updateYearOptions(); // Update year options based on selectedChannelId
            updateChannelOptions(); // Update channel options based on selectedYear
        } catch (error) {
            console.error("Error updating dropdown options:", error);
        }
        // --- End Update Dropdown Options ---

        // --- Apply Filters ---
        let filteredVideos = [...allVideos]; // Clone the array to avoid issues
        try {
            if (selectedYear !== "all") {
                // Ensure filtering uses optional chaining for safety if published_at is missing
                filteredVideos = filteredVideos.filter((video) =>
                    video?.published_at?.startsWith(selectedYear)
                );
            }
            if (selectedChannelId !== "all") {
                filteredVideos = filteredVideos.filter(
                    (video) => video?.video_owner_channel_id === selectedChannelId
                );
            }
        } catch (error) {
            console.error("Error filtering videos:", error);
            // Fallback to unfiltered list
            filteredVideos = [...allVideos];
        }
        // --- End Apply Filters ---
        
        // Guard against invalid data
        if (!Array.isArray(filteredVideos)) {
            console.error("Filtered videos is not an array");
            filteredVideos = [];
        }

        const currentTotalItems = filteredVideos.length;
        totalPages = Math.ceil(currentTotalItems / itemsPerPage) || 1; // Ensure at least 1 page
        
        console.log("Pagination calculation:", {
            filteredCount: currentTotalItems,
            totalPages: totalPages,
            currentPage: currentPage
        });
        
        // Ensure currentPage is valid after filtering
        if (currentPage > totalPages) {
            currentPage = totalPages; // Go to last page if current page is too high
        }
        currentPage = Math.max(1, currentPage); // Ensure it's at least 1

        const offset = (currentPage - 1) * itemsPerPage;
        const videosToShow = filteredVideos.slice(offset, Math.min(offset + itemsPerPage, filteredVideos.length));
        
        console.log(`Showing ${videosToShow.length} videos on page ${currentPage}`);
        
        const maxLength = 40; // Max characters for title

        // Generate grid HTML or "No results" message
        if (videosToShow.length > 0) {
            try {
                gridContainer.innerHTML = videosToShow
                    .map((video) => {
                        if (!video) return ''; // Skip null/undefined items
                        
                        // Ensure title is a string, provide fallback
                        const title = typeof video.title === 'string' ? video.title : 'Untitled Video';
                        let displayTitle = title;
                        /* Comment out the truncation logic to show full titles
                        if (displayTitle.length > maxLength) {
                            const lastSpace = displayTitle.lastIndexOf(" ", maxLength - 1);
                            displayTitle = (lastSpace > maxLength / 2)
                                ? displayTitle.substring(0, lastSpace) + "â€¦"
                                : displayTitle.substring(0, maxLength - 1) + "â€¦";
                        }
                        */

                        const imageUrl = video.thumbnail_url;
                        // Ensure imageUrl is a string and looks like a valid URL before using it in <img>
                        const isValidImageUrl = typeof imageUrl === 'string' && imageUrl.trim() !== '' && imageUrl.startsWith('http');
                        const imageHtml = isValidImageUrl
                                ? `<img src="${imageUrl}" alt="${title}" loading="lazy" class="w-full aspect-video object-cover block"/>`
                                : `<div class="w-full aspect-video bg-gray-200 dark:bg-gray-600 flex items-center justify-center"><span class="text-xs text-gray-500 dark:text-gray-400">No Thumbnail</span></div>`;

                        // Ensure url is a string, provide fallback
                        const videoUrl = typeof video.url === 'string' ? video.url : '#';

                        return `
                    <a href="${videoUrl}" target="_blank" rel="noopener noreferrer" class="flex flex-col no-underline text-inherit rounded-lg overflow-hidden shadow-md hover:shadow-xl hover:-translate-y-1 transition duration-200 ease-in-out" title="${title}">
                        ${imageHtml}
                        <p class="px-3 pt-3 pb-4 text-sm m-0 leading-tight">${displayTitle}</p>
                    </a>
                `;
                    })
                    .filter(html => html) // Remove empty strings
                    .join("");
            } catch (error) {
                console.error("Error generating video grid:", error);
                gridContainer.innerHTML = `<div class="col-span-full text-center py-10 text-red-600">Error rendering videos. Please try refreshing the page.</div>`;
            }
        } else {
            gridContainer.innerHTML = `
                <div class="col-span-full text-center py-10">
                    <p class="text-lg text-[color:var(--text-secondary)]">No videos match your filters.<br>${selectedYear !== 'all' || selectedChannelId !== 'all' ? 'Try adjusting or clearing filters.' : ''}</p>
                </div>`;
        }

        // --- Update Page Select Dropdown ---
        if (pageTotalSpan) {
            pageTotalSpan.textContent = `of ${totalPages}`;
        }
        
        // Populate dropdown options
        if (pageSelect) {
            pageSelect.innerHTML = ''; // Clear previous options
            const maxOptionsToShow = 500; // Limit options for performance if totalPages is huge
            for (let i = 1; i <= Math.min(totalPages, maxOptionsToShow); i++) { // Ensure loop runs even if totalPages is 0
                const option = document.createElement('option');
                option.value = i.toString();
                option.textContent = i.toString();
                pageSelect.appendChild(option);
            }
            if (totalPages > maxOptionsToShow) {
                 const option = document.createElement('option');
                 option.value = currentPage.toString(); // Ensure current is selectable if > max
                 option.textContent = `${currentPage} (current)`;
                 option.disabled = true; // Visually indicate it might be outside normal range
                 pageSelect.appendChild(option);
                 console.warn(`Page dropdown limited to first ${maxOptionsToShow} options due to large number of pages.`);
            }
            pageSelect.value = currentPage.toString();
            pageSelect.disabled = totalPages <= 1; // Re-enable if we have multiple pages
        }
        // --- End Update Page Select ---

        // --- Show/Hide Remove Filters Button ---
        if (removeFiltersButton) {
            const filtersActive = selectedYear !== "all" || selectedChannelId !== "all";
            removeFiltersButton.classList.toggle("hidden", !filtersActive);
            removeFiltersButton.disabled = !filtersActive; // Also disable if not active
        }

        // Update button states
        const hasPrev = currentPage > 1;
        const hasNext = currentPage < totalPages;

        if (prevButton) {
            prevButton.classList.toggle("disabled", !hasPrev);
            prevButton.setAttribute("aria-disabled", (!hasPrev).toString());
        }

        if (nextButton) {
            nextButton.classList.toggle("disabled", !hasNext);
            nextButton.setAttribute("aria-disabled", (!hasNext).toString());
        }

        // Explicitly set form control values to match state
        if (yearSelect) yearSelect.value = selectedYear;
        if (channelSelect) channelSelect.value = selectedChannelId;
        if (limitSelect) limitSelect.value = itemsPerPage.toString();
    }

    // Function to load parameters from URL
    function loadParamsFromUrl() {
        const urlParams = new URLSearchParams(window.location.search);
        const urlPage = parseInt(urlParams.get("page") || "1");
        const urlLimit = parseInt(urlParams.get("limit") || validLimits[0].toString());
        const urlYear = urlParams.get("year") || "all";
        const urlChannel = urlParams.get("channel") || "all";
        
        // Set state from URL parameters
        itemsPerPage = validLimits.includes(urlLimit) ? urlLimit : validLimits[0];
        selectedYear = urlYear;
        selectedChannelId = urlChannel;
        currentPage = urlPage;
        
        debugLog("Loaded params from URL:", {
            page: currentPage,
            limit: itemsPerPage,
            year: selectedYear,
            channel: selectedChannelId
        });
    }

    async function initializeAndFetchData() {
        console.log("Initializing with pre-loaded data from Astro");
        isDataLoading = true; // Set to true initially, then false after processing
        if (errorMessageElement) errorMessageElement.classList.add('hidden');

        const urlParams = new URLSearchParams(window.location.search);
        const initialPage = parseInt(urlParams.get("page") || "1");
        const initialLimit = parseInt(urlParams.get("limit") || validLimits[0].toString());
        const initialYear = urlParams.get("year") || "all";
        const initialChannel = urlParams.get("channel") || "all";
        
        currentPage = initialPage;
        itemsPerPage = validLimits.includes(initialLimit) ? initialLimit : validLimits[0]; 
        selectedYear = initialYear;
        selectedChannelId = initialChannel;
        
        console.log("Initial state from URL:", {
            page: currentPage,
            limit: itemsPerPage,
            year: selectedYear, 
            channel: selectedChannelId
        });
        
        if (limitSelect) limitSelect.value = itemsPerPage.toString();
        if (yearSelect) yearSelect.value = selectedYear; // Will be refined by updateYearOptions
        if (channelSelect) channelSelect.value = selectedChannelId; // Will be refined by updateChannelOptions
        
        // renderPage(); // Show loading state - No, data is already here

        if (fetchErrorFromServer) {
            console.error("Error passed from server:", fetchErrorFromServer);
            isDataLoading = false;
            if (loadingIndicator) loadingIndicator.classList.add('hidden');
            if (errorMessageElement) {
                errorMessageElement.textContent = `Error loading videos: ${fetchErrorFromServer}. Please try refreshing the page.`;
                errorMessageElement.classList.remove('hidden');
            }
            if (gridContainer) {
                gridContainer.innerHTML = `<div class="col-span-full text-center py-10 text-red-600">Failed to load videos (server error). Please try refreshing.</div>`;
            }
             // Disable controls on server error
            if (limitSelect) limitSelect.disabled = true;
            if (yearSelect) yearSelect.disabled = true;
            if (channelSelect) channelSelect.disabled = true;
            if (removeFiltersButton) removeFiltersButton.disabled = true;
            if (prevButton) { prevButton.classList.add("disabled"); prevButton.setAttribute("aria-disabled", "true");}
            if (nextButton) { nextButton.classList.add("disabled"); nextButton.setAttribute("aria-disabled", "true");}
            if (pageSelect) pageSelect.disabled = true;
            if (pageTotalSpan) pageTotalSpan.textContent = "of ?";
            return; // Stop initialization if server-side error occurred
        }

        // Data (`allVideos`) is already populated from define:vars
        // We can treat it as if it was "fetched"
        console.log(`Using ${allVideos.length} videos passed from Astro frontmatter.`);

        if (!Array.isArray(allVideos)) { // Should not happen if Astro passes correctly
            console.error("Videos data from Astro is not an array!");
            allVideos = []; // Prevent further errors
            // Display an error
            if (loadingIndicator) loadingIndicator.classList.add('hidden');
            if (errorMessageElement) {
                errorMessageElement.textContent = "Internal error: Video data format is incorrect.";
                errorMessageElement.classList.remove('hidden');
            }
        }
            
        isDataLoading = false; // Mark loading as complete as data is from frontmatter

        // Validate current filters against loaded data (if not already done server-side)
        // The server-side uniqueYears/Channels should be mostly correct, but client might have stale URL params
        const currentAvailableYears = [...new Set(allVideos.map(v => v.published_at?.substring(0, 4)).filter(Boolean))];
        if (selectedYear !== "all" && !currentAvailableYears.includes(selectedYear)) {
            console.log(`Client: Selected year ${selectedYear} not in available [${currentAvailableYears.join()}], resetting to 'all'`);
            selectedYear = "all";
        }
        
        const currentAvailableChannels = [...new Set(allVideos.map(v => v.video_owner_channel_id).filter(Boolean))];
        if (selectedChannelId !== "all" && !currentAvailableChannels.includes(selectedChannelId)) {
            console.log(`Client: Selected channel ${selectedChannelId} not in available channels, resetting to 'all'`);
            selectedChannelId = "all";
        }
            
        renderPage(); // Initial render with pre-loaded data
        setupEventListeners();
            
        updateUrl(true); // Use replaceState during initialization to reflect any corrected params

        // No try-catch needed here for fetch, as data is pre-loaded.
        // Error handling for data loading is now in Astro frontmatter.
    }

    function setupEventListeners() {
        console.log("Setting up event listeners");
        
        if (!limitSelect || !yearSelect || !channelSelect || !prevButton || !nextButton || !pageSelect) {
            return;
        }

        // Helper to replace listeners (avoids duplicates)
        const replaceListener = (element, eventType, newHandler) => {
            if (element._handler) {
                element.removeEventListener(eventType, element._handler);
            }
            element.addEventListener(eventType, newHandler);
            element._handler = newHandler;
        };

        // Year filter change
        const handleYearChange = (event) => {
            const target = event.target;
            if (target && "value" in target) {
                selectedYear = target.value;
                currentPage = 1; // Reset to first page
                updateUrl(false); // Use pushState for user interaction
                renderPage();
            }
        };
        replaceListener(yearSelect, "change", handleYearChange);

        // Channel filter change
        const handleChannelChange = (event) => {
            const target = event.target;
            if (target && "value" in target) {
                selectedChannelId = target.value;
                currentPage = 1; // Reset to first page
                updateUrl(false); // Use pushState for user interaction
                renderPage();
            }
        };
        replaceListener(channelSelect, "change", handleChannelChange);

        // Items per page change
        const handleLimitChange = (event) => {
            const target = event.target;
            if (target && "value" in target) {
                const newLimit = parseInt(target.value);
                if (validLimits.includes(newLimit)) {
                    itemsPerPage = newLimit;
                    currentPage = 1; // Reset to first page
                    updateUrl(false); // Use pushState for user interaction
                    renderPage();
                }
            }
        };
        replaceListener(limitSelect, "change", handleLimitChange);

        // Navigation buttons
        const handlePrevClick = (event) => {
            event.preventDefault();
            if (isDataLoading || currentPage <= 1) return;
            
            currentPage--;
            updateUrl(false); // Use pushState for user interaction
            renderPage();
        };
        replaceListener(prevButton, "click", handlePrevClick);

        const handleNextClick = (event) => {
            event.preventDefault();
            if (isDataLoading || currentPage >= totalPages) return;
            
            currentPage++;
            updateUrl(false); // Use pushState for user interaction
            renderPage();
        };
        replaceListener(nextButton, "click", handleNextClick);

        // Clear filters button
        const handleRemoveFilters = (event) => {
            event.preventDefault();
            selectedYear = "all";
            selectedChannelId = "all";
            currentPage = 1;
            updateUrl(false); // Use pushState for user interaction
            renderPage();
        };
        if (removeFiltersButton) {
            replaceListener(removeFiltersButton, "click", handleRemoveFilters);
        }

        // Page select dropdown
        const handlePageSelectChange = (event) => {
            const target = event.target;
            if (target && "value" in target) {
                const newPage = parseInt(target.value);
                if (!isNaN(newPage) && newPage >= 1 && newPage <= totalPages) {
                    currentPage = newPage;
                    updateUrl(false); // Use pushState for user interaction
                    renderPage();
                }
            }
        };
        replaceListener(pageSelect, "change", handlePageSelectChange);

        // Handle browser back/forward buttons
        if (!window._popstateHandledVideos) {
            window.addEventListener("popstate", (event) => {
                console.log("POPSTATE triggered", event.state, window.location.search);
                
                // Simply reload the page on back/forward navigation for consistent behavior
                // This guarantees the page state will match the URL
                if (window.location.pathname.includes('/videos')) {
                    window.location.reload();
                }
            });
            window._popstateHandledVideos = true;
        }
    }

    function updateYearOptions() {
        try {
            if (!yearSelect || !allVideos || allVideos.length === 0) return;

            // Determine available years based on the *selected channel*
            const videosForSelectedChannel = selectedChannelId === "all"
                ? allVideos
                : allVideos.filter(v => v && v.video_owner_channel_id === selectedChannelId);

            const availableYears = [
                ...new Set(videosForSelectedChannel.map((v) => v?.published_at?.substring(0, 4)).filter(Boolean))
            ].sort((a, b) => parseInt(b) - parseInt(a)); // Sort descending

            // Preserve current selection if still valid
            const currentSelectedYearIsValid = availableYears.includes(selectedYear);
            if (!currentSelectedYearIsValid && selectedYear !== "all") {
                // If the current selection is no longer valid due to the channel filter,
                // we don't reset it here, as the user might be switching *between* filters.
                // The main filtering logic in renderPage will handle showing "no results".
                // We just ensure the option is visually available if possible.
            }

            // Update options
            let optionsHtml = '<option value="all">All Years</option>';
            availableYears.forEach(year => {
                optionsHtml += `<option value="${year}" ${year === selectedYear ? 'selected' : ''}>${year}</option>`;
            });

            // Add the currently selected year back if it was filtered out, but keep it selected
            // This prevents the dropdown from visually resetting while the user is actively filtering
            if (selectedYear !== "all" && !availableYears.includes(selectedYear)) {
                optionsHtml += `<option value="${selectedYear}" selected style="display: none;">${selectedYear} (filtered)</option>`; // Add hidden option
            }

            yearSelect.innerHTML = optionsHtml;
            yearSelect.value = selectedYear; // Ensure the value property matches state
            yearSelect.disabled = availableYears.length === 0 && selectedChannelId === "all"; // Disable only if truly no options
            
        } catch (error) {
            console.error("Error updating year options:", error);
            // Fallback to a basic option
            if (yearSelect) {
                yearSelect.innerHTML = '<option value="all">All Years</option>';
                yearSelect.value = "all";
            }
        }
    }

    function updateChannelOptions() {
        try {
            if (!channelSelect || !allVideos || allVideos.length === 0) return;

            // Determine available channels based on the *selected year*
            const videosForSelectedYear = selectedYear === "all"
                ? allVideos
                : allVideos.filter(v => v && v.published_at?.startsWith(selectedYear));

            const availableChannelsMap = new Map();
            videosForSelectedYear.forEach((v) => {
                if (v && v.video_owner_channel_id && !availableChannelsMap.has(v.video_owner_channel_id)) {
                    availableChannelsMap.set(
                        v.video_owner_channel_id,
                        v.video_owner_channel_title || 'Unknown Channel'
                    );
                }
            });

            const availableChannels = Array.from(availableChannelsMap.entries())
                .map(([id, title]) => ({ id, title }))
                .sort((a, b) => a.title.localeCompare(b.title)); // Sort alphabetically

            // Preserve current selection if still valid
            const currentSelectedChannelIsValid = availableChannels.some(c => c.id === selectedChannelId);
            if (!currentSelectedChannelIsValid && selectedChannelId !== "all") {
                // Similar logic as for years - don't reset automatically
            }

            // Update options
            let optionsHtml = '<option value="all">All Channels</option>';
            const maxLen = 15; // Title truncation length
            availableChannels.forEach(channel => {
                const displayTitle = channel.title.length > maxLen
                    ? channel.title.substring(0, maxLen) + "â€¦"
                    : channel.title;
                optionsHtml += `<option value="${channel.id}" title="${channel.title}" ${channel.id === selectedChannelId ? 'selected' : ''}>${displayTitle}</option>`;
            });

            // Add the currently selected channel back if it was filtered out, but keep it selected
            if (selectedChannelId !== "all" && !availableChannels.some(c => c.id === selectedChannelId)) {
                // Find the original title from build-time data or fallback
                const originalChannel = uniqueChannelsFromBuild.find(c => c.id === selectedChannelId);
                const title = originalChannel ? originalChannel.title : 'Unknown Channel (filtered)';
                const displayTitle = title.length > maxLen ? title.substring(0, maxLen) + "â€¦" : title;
                optionsHtml += `<option value="${selectedChannelId}" title="${title}" selected style="display: none;">${displayTitle} (filtered)</option>`; // Add hidden option
            }

            channelSelect.innerHTML = optionsHtml;
            channelSelect.value = selectedChannelId; // Ensure the value property matches state
            channelSelect.disabled = availableChannels.length === 0 && selectedYear === "all"; // Disable only if truly no options
            
        } catch (error) {
            console.error("Error updating channel options:", error);
            // Fallback to a basic option
            if (channelSelect) {
                channelSelect.innerHTML = '<option value="all">All Channels</option>';
                channelSelect.value = "all";
            }
        }
    }

    // Start the process on page load
    initializeAndFetchData();

</script>

<style is:global>
    /* Thin scrollbar for #page-select in Webkit browsers */
    #page-select::-webkit-scrollbar {
      width: 5px;
    }

    #page-select::-webkit-scrollbar-track {
      background: transparent;
    }

    #page-select::-webkit-scrollbar-thumb {
      background-color: var(--text-secondary);
      border-radius: 10px;
      border: none;
    }

    /* Thin scrollbar for #page-select in Firefox */
    #page-select {
      scrollbar-width: thin;
      scrollbar-color: var(--text-secondary) transparent;
    }
</style>
