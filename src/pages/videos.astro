---
import BaseLayout from "../layouts/BaseLayout.astro";
// Try importing using the '@' alias
import videosData from "../../public/os-bookmarks/liked_videos.json" with { type: "json" };

// Define the expected structure of a video object
interface Video {
    title: string;
    thumbnail_url: string;
    url: string;
    // Add other properties if they exist in your JSON
    video_owner_channel_id: string; // Added for filtering
    video_owner_channel_title: string; // Added for filtering
    published_at: string; // Added for filtering
}

const title = "Videos - Al Harkan";
const description =
    "Videos Curation on AI Research, Software, and Digital Media";
const permalink = Astro.site?.href ? `${Astro.site.href}videos` : "/videos";

// --- Filter Data Extraction ---
const uniqueYears = [
    ...new Set(videosData.map((v) => v.published_at.substring(0, 4))),
].sort((a, b) => parseInt(b) - parseInt(a)); // Sort descending

const uniqueChannelsMap = new Map<string, string>();
videosData.forEach((v) => {
    if (!uniqueChannelsMap.has(v.video_owner_channel_id)) {
        uniqueChannelsMap.set(
            v.video_owner_channel_id,
            v.video_owner_channel_title,
        );
    }
});
const uniqueChannels = Array.from(uniqueChannelsMap.entries())
    .map(([id, title]) => ({ id, title }))
    .sort((a, b) => a.title.localeCompare(b.title)); // Sort alphabetically by title
// --- End Filter Data Extraction ---

// Pagination logic
// const urlParams = Astro.url.searchParams; // Previous method
const requestUrl = new URL(Astro.request.url);
const urlParams = requestUrl.searchParams; // Get params from request URL
// console.log("--- Videos Page Re-rendering ---");
// console.log("Astro.url:", Astro.url.toString()); // Keep if useful, might be stale
// console.log("Astro.request.url:", Astro.request.url);
// console.log("Raw Params from request:", urlParams.toString());

const validLimits = [30, 60, 90];
let limit = parseInt(urlParams.get("limit") || "30");
if (!validLimits.includes(limit)) {
    limit = 30; // Default to 50 if invalid limit
}
const page = parseInt(urlParams.get("page") || "1");
const totalItems = videosData.length;
const totalPages = Math.ceil(totalItems / limit);
const currentPage = Math.max(1, Math.min(page, totalPages)); // Clamp page number
const offset = (currentPage - 1) * limit;
// console.log(`Parsed Params: page=${page}, limit=${limit}`);
// console.log(`Calculated: currentPage=${currentPage}, totalPages=${totalPages}, offset=${offset}, totalItems=${totalItems}`);

// Explicitly type the sliced array
const videosToShow: Video[] = videosData.slice(offset, offset + limit);
// console.log(`Videos to show: ${videosToShow.length}`);

const hasPrevPage = currentPage > 1;
const hasNextPage = currentPage < totalPages;
const prevPageUrl = hasPrevPage
    ? `?page=${currentPage - 1}&limit=${limit}`
    : "#";
const nextPageUrl = hasNextPage
    ? `?page=${currentPage + 1}&limit=${limit}`
    : "#";
---

<BaseLayout
    title={title}
    description={description}
    permalink={permalink ?? "/"}
    current="bookmarks"
>
    <div class="container">
        <h1 class="!mb-4">My {totalItems} Liked Videos</h1>
        <p class="!m-0">On AI Research, Software, and Digital Media</p>
        <hr />

        <!-- Filter Controls -->
        <div
            class="filter-controls flex flex-row flex-wrap justify-center gap-x-4 gap-y-2 my-4 sm:justify-center sm:items-center"
        >
            <div class="flex items-center gap-x-2 justify-between">
                <select
                    id="year-select"
                    class="border rounded px-2 py-1 text-sm bg-[var(--background-body)] text-[var(--text-main)] border-gray-300 dark:border-gray-600 w-full"
                >
                    <option value="all">All Years</option>
                    {
                        uniqueYears.map((year) => (
                            <option value={year}>{year}</option>
                        ))
                    }
                </select>
            </div>
            <div class="flex items-center gap-x-2 justify-between">
                <select
                    id="channel-select"
                    class="border rounded px-2 py-1 text-sm bg-[var(--background-body)] text-[var(--text-main)] border-gray-300 dark:border-gray-600 w-full"
                >
                    <option value="all">All Channels</option>
                    {
                        uniqueChannels.map((channel) => {
                            const maxLen = 15;
                            const displayTitle =
                                channel.title.length > maxLen
                                    ? channel.title.substring(0, maxLen) + "…"
                                    : channel.title;
                            return (
                                <option
                                    value={channel.id}
                                    title={channel.title}
                                >
                                    {displayTitle}
                                </option>
                            );
                        })
                    }
                </select>
            </div>
            <!-- Remove Filter Button (hidden by default) -->
            <button
                id="remove-filters-button"
                class="hidden text-sm hover:underline focus:outline-none flex justify-start items-center"
            >
                <p class="text-sm">Clear Filters</p>
            </button>

            {/* Items per page selector */}
            <div class="pagination-limit flex items-center">
                <select
                    id="limit-select"
                    class="border rounded px-2 py-1 text-sm bg-[var(--background-body)]"
                >
                    {validLimits.map((l) => <option value={l}>{l}</option>)}
                </select>
                <p class="ml-2 text-sm whitespace-nowrap">per Page</p>
            </div>
        </div>

        <!-- Video Grid -->
        <div
            id="video-grid-container"
            class="grid grid-cols-[repeat(auto-fill,minmax(200px,1fr))] gap-6 mt-8 mb-8 min-h-[200px]"
        >
            {/* Centered loading indicator */}
            <div
                class="col-span-full flex flex-col items-center justify-center min-h-[200px]"
            >
                <div
                    class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-[var(--primary-color)]"
                >
                </div>
                <p class="mt-4">Loading Videos...</p>
            </div>
        </div>

        <!-- Pagination Controls -->
        {
            totalItems > 0 && (
                <div class="pagination-controls flex flex-row flex-nowrap justify-center items-center gap-2 sm:gap-4 my-6">
                    {/* Navigation buttons and page info */}
                        <a
                            id="prev-button"
                            href="#"
                            class="nav-button disabled text-[color:var(--text-secondary)] font-sans text-sm font-bold no-underline transition-all duration-200 ease-in-out shadow-[inset_0_-0.12em_0_var(--primary-color)] hover:shadow-[inset_0_-1.5em_0_var(--primary-color)] hover:text-white aria-disabled:opacity-50 aria-disabled:cursor-not-allowed aria-disabled:pointer-events-none aria-disabled:shadow-[inset_0_-0.12em_0_var(--text-secondary)] aria-disabled:hover:text-[color:var(--text-secondary)]"
                            aria-disabled="true"
                        >
                            &laquo; Prev
                        </a>
                        <span
                            id="page-info"
                            class="text-sm px-2 whitespace-nowrap"
                        >
                            Page loading...
                        </span>
                        <a
                            id="next-button"
                            href="#"
                            class="nav-button disabled text-[color:var(--text-secondary)] font-sans text-sm font-bold no-underline transition-all duration-200 ease-in-out shadow-[inset_0_-0.12em_0_var(--primary-color)] hover:shadow-[inset_0_-1.5em_0_var(--primary-color)] hover:text-white aria-disabled:opacity-50 aria-disabled:cursor-not-allowed aria-disabled:pointer-events-none aria-disabled:shadow-[inset_0_-0.12em_0_var(--text-secondary)] aria-disabled:hover:text-[color:var(--text-secondary)]"
                            aria-disabled="true"
                        >
                            Next &raquo;
                        </a>
                </div>
            )
        }
        <hr />
        <p class="footnote text-sm">
            This video playlist is automatically updated daily and synced with
            my YouTube account —<a href="https://www.youtube.com/@alhrkn/playlists" target="_blank" rel="noopener noreferrer">check it out</a> for more playlists!
        </p>
    </div>
</BaseLayout>

<script
    define:vars={{
        allVideos: videosData,
        validLimits,
        uniqueYears,
        uniqueChannels,
    }}
>
    // Get elements
    const gridContainer = document.getElementById("video-grid-container");
    const prevButton = document.getElementById("prev-button");
    const nextButton = document.getElementById("next-button");
    const pageInfo = document.getElementById("page-info");
    const limitSelect = document.getElementById("limit-select");
    const yearSelect = document.getElementById("year-select"); // New filter element
    const channelSelect = document.getElementById("channel-select"); // New filter element
    const removeFiltersButton = document.getElementById(
        "remove-filters-button",
    ); // New button

    // State variables
    let currentPage = 1;
    let itemsPerPage = validLimits[0];
    const globalTotalItems = allVideos.length; // Keep track of the original total
    let totalPages = 1;
    let selectedYear = "all"; // New filter state
    let selectedChannelId = "all"; // New filter state

    function updateUrl() {
        const url = new URL(window.location.href);
        url.searchParams.set("page", currentPage.toString());
        url.searchParams.set("limit", itemsPerPage.toString());
        url.searchParams.set("year", selectedYear); // Add year param
        url.searchParams.set("channel", selectedChannelId); // Add channel param
        // Use pushState to change URL without reloading
        history.pushState({}, "", url.toString());
    }

    function renderPage() {
        if (
            !gridContainer ||
            !pageInfo ||
            !prevButton ||
            !nextButton ||
            !limitSelect ||
            !yearSelect ||
            !channelSelect
        )
            return;

        // --- Apply Filters ---
        let filteredVideos = allVideos;
        if (selectedYear !== "all") {
            filteredVideos = filteredVideos.filter((video) =>
                video.published_at.startsWith(selectedYear),
            );
        }
        if (selectedChannelId !== "all") {
            filteredVideos = filteredVideos.filter(
                (video) => video.video_owner_channel_id === selectedChannelId,
            );
        }
        // --- End Apply Filters ---

        const currentTotalItems = filteredVideos.length;
        totalPages = Math.ceil(currentTotalItems / itemsPerPage);
        // Clamp currentPage based on filtered results
        currentPage = Math.max(
            1,
            Math.min(currentPage, totalPages > 0 ? totalPages : 1),
        ); // Ensure currentPage is at least 1

        const offset = (currentPage - 1) * itemsPerPage;
        const videosToShow = filteredVideos.slice(
            offset,
            offset + itemsPerPage,
        );

        const maxLength = 40; // Max characters for title

        // Generate grid HTML or "No results" message
        if (videosToShow.length > 0) {
            gridContainer.innerHTML = videosToShow
                .map((video) => {
                    let displayTitle = video.title;
                    if (displayTitle.length > maxLength) {
                        // Find the last space before maxLength to avoid cutting words
                        const lastSpace = displayTitle.lastIndexOf(
                            " ",
                            maxLength - 1,
                        );
                        if (lastSpace > maxLength / 2) {
                            // Only truncate at space if it's reasonably far in
                            displayTitle =
                                displayTitle.substring(0, lastSpace) + "…";
                        } else {
                            displayTitle =
                                displayTitle.substring(0, maxLength - 1) + "…"; // Hard cut if no good space
                        }
                    }

                    // Check for valid thumbnail URL
                    const imageUrl = video.thumbnail_url;
                    const imageHtml =
                        imageUrl &&
                        typeof imageUrl === "string" &&
                        imageUrl.trim() !== ""
                            ? `<img
                            src="${imageUrl}"
                            alt="${video.title}" // Keep full title for alt text
                            loading="lazy"
                            class="w-full aspect-video object-cover block"
                        />`
                            : `<div class="w-full aspect-video bg-gray-200 dark:bg-gray-600 flex items-center justify-center">
                            <span class="text-xs text-gray-500 dark:text-gray-400">No Thumbnail</span>
                        </div>`;

                    return `
                <a
                    href="${video.url}"
                    target="_blank"
                    rel="noopener noreferrer"
                    class="flex flex-col no-underline text-inherit rounded-lg overflow-hidden shadow-md hover:shadow-xl hover:-translate-y-1 transition duration-200 ease-in-out"
                    title="${video.title}" // Keep full title for hover tooltip
                >
                    ${imageHtml}
                    <p class="px-3 pt-3 pb-4 text-sm m-0 leading-tight">
                        ${displayTitle}
                    </p>
                </a>
            `;
                })
                .join("");
        } else {
            gridContainer.innerHTML = `
                <div class="col-span-full text-center py-10">
                    <p class="text-lg text-[color:var(--text-secondary)]">No videos match your filters.<br>Try removing a filter.</p>
                </div>
             `;
        }

        // Update pagination info
        pageInfo.textContent = `Page ${currentPage} of ${totalPages > 0 ? totalPages : 1}`; // Show Page 1 of 1 if no results

        // --- Show/Hide Remove Filters Button ---
        if (removeFiltersButton) {
            const filtersActive =
                selectedYear !== "all" || selectedChannelId !== "all";
            removeFiltersButton.classList.toggle("hidden", !filtersActive);
        }
        // --- End Show/Hide ---

        // Update button states and links (disable if no pages or only one page)
        const hasPrev = currentPage > 1 && totalPages > 0;
        const hasNext = currentPage < totalPages && totalPages > 0;

        prevButton.classList.toggle("disabled", !hasPrev);
        prevButton.setAttribute("aria-disabled", (!hasPrev).toString());
        prevButton.href = hasPrev ? "#" : "#"; // Href updated in handler, just control state here

        nextButton.classList.toggle("disabled", !hasNext);
        nextButton.setAttribute("aria-disabled", (!hasNext).toString());
        nextButton.href = hasNext ? "#" : "#"; // Href updated in handler, just control state here

        // Update selected limit, year, and channel in dropdowns
        limitSelect.value = itemsPerPage.toString();
        yearSelect.value = selectedYear;
        channelSelect.value = selectedChannelId;
    }

    function handleNavClick(event, newPage) {
        event.preventDefault(); // Prevent default link navigation
        // Calculate totalPages based on current filters and itemsPerPage *before* checking bounds
        let currentFilteredVideos = allVideos;
        if (selectedYear !== "all") {
            currentFilteredVideos = currentFilteredVideos.filter((video) =>
                video.published_at.startsWith(selectedYear),
            );
        }
        if (selectedChannelId !== "all") {
            currentFilteredVideos = currentFilteredVideos.filter(
                (video) => video.video_owner_channel_id === selectedChannelId,
            );
        }
        const currentTotalItems = currentFilteredVideos.length;
        const currentTotalPages = Math.ceil(currentTotalItems / itemsPerPage);

        if (
            newPage < 1 ||
            newPage > (currentTotalPages > 0 ? currentTotalPages : 1)
        )
            return; // Check bounds against current filtered total pages

        currentPage = newPage;
        updateUrl();
        renderPage();
    }

    function initPagination() {
        if (!limitSelect || !yearSelect || !channelSelect) return; // Ensure elements exist

        const urlParams = new URLSearchParams(window.location.search);
        const initialPage = parseInt(urlParams.get("page") || "1");
        const initialLimit = parseInt(
            urlParams.get("limit") || validLimits[0].toString(),
        );
        const initialYear = urlParams.get("year") || "all";
        const initialChannel = urlParams.get("channel") || "all";

        // Set Limit
        if (!isNaN(initialLimit) && validLimits.includes(initialLimit)) {
            itemsPerPage = initialLimit;
        } else {
            itemsPerPage = validLimits[0]; // Default if invalid limit in URL
        }
        limitSelect.value = itemsPerPage.toString(); // Set initial dropdown value

        // Set Year Filter
        // Validate initialYear against uniqueYears (passed from server)
        if (initialYear === "all" || uniqueYears.includes(initialYear)) {
            selectedYear = initialYear;
        } else {
            selectedYear = "all"; // Default if invalid
        }
        yearSelect.value = selectedYear;

        // Set Channel Filter
        // Validate initialChannel against uniqueChannels (passed from server)
        const validChannelIds = ["all", ...uniqueChannels.map((c) => c.id)];
        if (validChannelIds.includes(initialChannel)) {
            selectedChannelId = initialChannel;
        } else {
            selectedChannelId = "all"; // Default if invalid
        }
        channelSelect.value = selectedChannelId;

        // Apply filters to determine initial total pages before setting current page
        let initialFilteredVideos = allVideos;
        if (selectedYear !== "all") {
            initialFilteredVideos = initialFilteredVideos.filter((video) =>
                video.published_at.startsWith(selectedYear),
            );
        }
        if (selectedChannelId !== "all") {
            initialFilteredVideos = initialFilteredVideos.filter(
                (video) => video.video_owner_channel_id === selectedChannelId,
            );
        }
        const initialTotalItems = initialFilteredVideos.length;
        totalPages = Math.ceil(initialTotalItems / itemsPerPage); // Set initial totalPages based on filters

        // Set Current Page
        if (
            !isNaN(initialPage) &&
            initialPage >= 1 &&
            initialPage <= (totalPages > 0 ? totalPages : 1)
        ) {
            currentPage = initialPage;
        } else {
            currentPage = 1; // Default if invalid page in URL or no pages
        }

        // Initial render
        renderPage();
        // Update URL to reflect initial state (or cleaned state)
        updateUrl();

        // Add event listeners

        // --- Remove existing listeners first to avoid duplicates on popstate/HMR ---
        // Helper to remove/add listener
        const replaceListener = (element, eventType, newHandler) => {
            if (element._handler) {
                // Remove previous handler if stored
                element.removeEventListener(eventType, element._handler);
            }
            element.addEventListener(eventType, newHandler);
            element._handler = newHandler; // Store the new handler
        };

        // --- Filter Listeners ---
        const handleYearChange = (event) => {
            const target = event.target;
            if (target && "value" in target) {
                selectedYear = target.value;
                currentPage = 1; // Reset to first page on filter change
                updateUrl();
                renderPage();
            }
        };
        replaceListener(yearSelect, "change", handleYearChange);

        const handleChannelChange = (event) => {
            const target = event.target;
            if (target && "value" in target) {
                selectedChannelId = target.value;
                currentPage = 1; // Reset to first page on filter change
                updateUrl();
                renderPage();
            }
        };
        replaceListener(channelSelect, "change", handleChannelChange);

        // --- Pagination Listeners ---
        const handleLimitChange = (event) => {
            const target = event.target;
            if (target && "value" in target) {
                const newLimit = parseInt(target.value);
                if (!isNaN(newLimit) && validLimits.includes(newLimit)) {
                    itemsPerPage = newLimit;
                    currentPage = 1; // Reset to first page on limit change
                    updateUrl();
                    renderPage();
                }
            }
        };
        replaceListener(limitSelect, "change", handleLimitChange);

        const handlePrevClick = (event) => {
            handleNavClick(event, currentPage - 1);
        };
        replaceListener(prevButton, "click", handlePrevClick);

        const handleNextClick = (event) => {
            handleNavClick(event, currentPage + 1);
        };
        replaceListener(nextButton, "click", handleNextClick);

        // --- Remove Filters Listener ---
        const handleRemoveFilters = (event) => {
            event.preventDefault();
            selectedYear = "all";
            selectedChannelId = "all";
            currentPage = 1;
            updateUrl();
            renderPage(); // This will also hide the button again
        };
        if (removeFiltersButton) {
            replaceListener(removeFiltersButton, "click", handleRemoveFilters);
        }

        // Handle browser back/forward buttons
        // Avoid adding multiple popstate listeners
        if (!window._popstateHandled) {
            window.addEventListener("popstate", () => {
                // console.log("Popstate triggered, re-initializing pagination.");
                initPagination(); // Re-initialize based on the new URL state
            });
            window._popstateHandled = true;
        }
    }

    // Run initialization when the DOM is ready
    // Use standard DOMContentLoaded listener
    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initPagination);
    } else {
        // DOM is already loaded, but Astro might still be initializing islands/scripts.
        // A small timeout can sometimes help ensure dependent elements are ready,
        // though ideally Astro's lifecycle handles this.
        // Alternatively, if issues persist, consider Astro's client:visible or client:idle directives.
        setTimeout(initPagination, 0); // Use setTimeout 0 to queue after current JS execution
    }
</script>
