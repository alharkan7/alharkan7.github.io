---
import BaseLayout from "../layouts/BaseLayout.astro";
import { readFile } from 'node:fs/promises'; // Import Node.js fs for build-time reading
import path from 'node:path';

// Define the expected structure of a video object
interface Video {
    title: string;
    thumbnail_url: string;
    url: string;
    video_owner_channel_id: string;
    video_owner_channel_title: string;
    published_at: string;
}

const title = "Videos - Al Harkan";
const description =
    "Videos Curation on AI Research, Software, and Digital Media";
const permalink = Astro.site?.href ? `${Astro.site.href}videos` : "/videos";

// --- Build-time Data Extraction for Filters & Count ---
let buildTimeVideosData: Video[] = [];
let totalItems = 0;
let uniqueYears: string[] = [];
let uniqueChannels: { id: string; title: string }[] = [];
let errorMessage: string | null = null;

try {
    // Construct the absolute path relative to the project root
    const jsonPath = path.resolve('public/os-bookmarks/liked_videos.json');
    // console.log(`Reading JSON from: ${jsonPath}`); // Debug path
    const jsonData = await readFile(jsonPath, 'utf-8');
    let allParsedVideos = JSON.parse(jsonData);

    // Filter out "Private video" entries *before* counting or processing
    buildTimeVideosData = allParsedVideos.filter((video: Video) => video.title !== "Private video");

    // Calculate total items based on the *filtered* data
    totalItems = buildTimeVideosData.length;

    // Now extract unique years and channels from the filtered data
    uniqueYears = [
        ...new Set(buildTimeVideosData.map((v) => v.published_at.substring(0, 4))),
].sort((a, b) => parseInt(b) - parseInt(a)); // Sort descending

const uniqueChannelsMap = new Map<string, string>();
    buildTimeVideosData.forEach((v) => {
        if (v.video_owner_channel_id && !uniqueChannelsMap.has(v.video_owner_channel_id)) {
        uniqueChannelsMap.set(
            v.video_owner_channel_id,
                v.video_owner_channel_title || 'Unknown Channel', // Provide fallback
        );
    }
});
    uniqueChannels = Array.from(uniqueChannelsMap.entries())
    .map(([id, title]) => ({ id, title }))
    .sort((a, b) => a.title.localeCompare(b.title)); // Sort alphabetically by title

    // Clear the large data structure after extracting info to prevent accidental bundling
    buildTimeVideosData = [];

} catch (error) {
    console.error("Error reading or processing liked_videos.json during build:", error);
    errorMessage = "Could not load video data during build. Filters might be unavailable.";
    // Assign default empty values if build fails
    totalItems = 0;
    uniqueYears = [];
    uniqueChannels = [];
}
// --- End Build-time Data Extraction ---


// --- Initial State from URL (Client will refine) ---
// We still need validLimits defined for the client script to use
const validLimits = [30, 60, 90];
// Basic check for initial limit to pass, client will validate more strictly
const requestUrl = new URL(Astro.request.url);
const urlParams = requestUrl.searchParams;
let initialLimit = parseInt(urlParams.get("limit") || validLimits[0].toString());
if (!validLimits.includes(initialLimit)) {
    initialLimit = validLimits[0];
}
// --- End Initial State ---

---

<BaseLayout
    title={title}
    description={description}
    permalink={permalink ?? "/"}
    current="bookmarks"
>
    <div class="container">
        <h1 class="!mb-4">My {totalItems > 0 ? `${totalItems} ` : ''}Liked Videos</h1>
        <p class="!m-0">On AI Research, Software, and Digital Media</p>
        <hr />

        <!-- Error Message Display -->
        {errorMessage && (
            <div class="my-4 p-4 bg-red-100 border border-red-400 text-red-700 rounded">
                <p><strong>Build Error:</strong> {errorMessage}</p>
            </div>
        )}

        <!-- Filter Controls (Render based on build-time data) -->
        <div
            class="filter-controls flex flex-row flex-wrap justify-center gap-x-4 gap-y-2 my-4 sm:justify-center sm:items-center"
        >
            <div class="flex items-center gap-x-2 justify-between">
                <select
                    id="year-select"
                    class="border rounded px-2 py-1 text-sm bg-[var(--background-body)] text-[var(--text-main)] border-gray-300 dark:border-gray-600 w-full"
                    disabled={uniqueYears.length === 0}
                >
                    <option value="all">All Years</option>
                    {
                        uniqueYears.map((year) => (
                            <option value={year}>{year}</option>
                        ))
                    }
                </select>
            </div>
            <div class="flex items-center gap-x-2 justify-between">
                <select
                    id="channel-select"
                    class="border rounded px-2 py-1 text-sm bg-[var(--background-body)] text-[var(--text-main)] border-gray-300 dark:border-gray-600 w-full"
                     disabled={uniqueChannels.length === 0}
                >
                    <option value="all">All Channels</option>
                    {
                        uniqueChannels.map((channel) => {
                            const maxLen = 15;
                            const displayTitle =
                                channel.title.length > maxLen
                                    ? channel.title.substring(0, maxLen) + "…"
                                    : channel.title;
                            return (
                                <option
                                    value={channel.id}
                                    title={channel.title}
                                >
                                    {displayTitle}
                                </option>
                            );
                        })
                    }
                </select>
            </div>
            <!-- Remove Filter Button (hidden by default) -->
            <button
                id="remove-filters-button"
                class="hidden text-sm hover:underline focus:outline-none flex justify-start items-center"
                disabled
            >
                <p class="text-sm">Clear Filters</p>
            </button>

            {/* Items per page selector */}
            <div class="pagination-limit flex items-center">
                <select
                    id="limit-select"
                    class="border rounded px-2 py-1 text-sm bg-[var(--background-body)]"
                    disabled={totalItems === 0}
                >
                    {validLimits.map((l) => (
                       <option value={l} selected={l === initialLimit}>{l}</option>
                    ))}
                </select>
                <p class="ml-2 text-sm whitespace-nowrap">per Page</p>
            </div>
        </div>

        <!-- Video Grid -->
        <div
            id="video-grid-container"
            class="grid grid-cols-[repeat(auto-fill,minmax(200px,1fr))] gap-6 mt-8 mb-8 min-h-[200px]"
        >
            {/* Initial Loading Indicator */}
            <div id="loading-indicator" class="col-span-full flex flex-col items-center justify-center min-h-[200px]">
                 <div class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-[var(--primary-color)]"></div>
                 <p class="mt-4 text-center">Loading Videos...</p>
                 <p id="error-message" class="mt-2 text-red-600 text-sm text-center hidden"></p>
            </div>
            {/* Content will be injected here by JS */}
        </div>


        <!-- Pagination Controls -->
        { totalItems > 0 ? ( // Only show pagination structure if items exist (based on build count)
                <div class="pagination-controls flex flex-row flex-nowrap justify-center items-center gap-2 sm:gap-4 my-6">
                    {/* Navigation buttons and page info */}
                        <a
                            id="prev-button"
                            href="#"
                            class="mr-2 nav-button disabled text-[color:var(--text-secondary)] font-sans text-sm font-bold no-underline transition-all duration-200 ease-in-out shadow-[inset_0_-0.12em_0_var(--primary-color)] hover:shadow-[inset_0_-1.5em_0_var(--primary-color)] hover:text-white aria-disabled:opacity-50 aria-disabled:cursor-not-allowed aria-disabled:pointer-events-none aria-disabled:shadow-[inset_0_-0.12em_0_var(--text-secondary)] aria-disabled:hover:text-[color:var(--text-secondary)]"
                            aria-disabled="true"
                        >
                            &laquo; Prev
                        </a>
                        <!-- New Page Select Dropdown -->
                        <div class="page-select-container flex items-center text-sm px-1 whitespace-nowrap">
                             <span class="mr-1">Page</span>
                             <select
                                id="page-select"
                                class="p-1 text-sm bg-[var(--background-body)] text-[var(--text-main)] text-center"
                                disabled
                                aria-label="Select page number"
                            >
                                <option value="1">1</option> {/* Placeholder */}
                            </select>
                            <span id="page-total-span" class="ml-2">of ?</span>
                        </div>
                        <a
                            id="next-button"
                            href="#"
                            class="ml-2 nav-button disabled text-[color:var(--text-secondary)] font-sans text-sm font-bold no-underline transition-all duration-200 ease-in-out shadow-[inset_0_-0.12em_0_var(--primary-color)] hover:shadow-[inset_0_-1.5em_0_var(--primary-color)] hover:text-white aria-disabled:opacity-50 aria-disabled:cursor-not-allowed aria-disabled:pointer-events-none aria-disabled:shadow-[inset_0_-0.12em_0_var(--text-secondary)] aria-disabled:hover:text-[color:var(--text-secondary)]"
                            aria-disabled="true"
                        >
                            Next &raquo;
                        </a>
                </div>
            ) : errorMessage ? null : (
                 <div class="text-center text-gray-500 my-6">No videos found.</div>
            )
        }
        <hr />
        <p class="footnote text-sm">
            This video playlist is automatically updated daily and synced with
            my YouTube account —<a href="https://www.youtube.com/@alhrkn/playlists" target="_blank" rel="noopener noreferrer">check it out</a> for more playlists!
        </p>
    </div>
</BaseLayout>

<script
    define:vars={{
        // Pass only necessary data, NOT the full video list
        initialTotalItems: totalItems,
        validLimits,
        initialUniqueYears: uniqueYears, // Pass build-time filters
        initialUniqueChannels: uniqueChannels, // Pass build-time filters
        jsonUrl: '/os-bookmarks/liked_videos.json' // URL to fetch
    }}
>
    // Get elements
    const gridContainer = document.getElementById("video-grid-container");
    const prevButton = document.getElementById("prev-button");
    const nextButton = document.getElementById("next-button");
    const pageSelect = document.getElementById("page-select"); // New page dropdown
    const pageTotalSpan = document.getElementById("page-total-span"); // Span for \"of Y\"
    const limitSelect = document.getElementById("limit-select");
    const yearSelect = document.getElementById("year-select");
    const channelSelect = document.getElementById("channel-select");
    const removeFiltersButton = document.getElementById("remove-filters-button");
    const loadingIndicator = document.getElementById("loading-indicator");
    const errorMessageElement = document.getElementById("error-message"); // Added error message display

    // State variables
    let allVideos = []; // Will be populated by fetch
    let isDataLoading = true;
    let currentPage = 1;
    let itemsPerPage = validLimits[0];
    let totalPages = 1;
    let selectedYear = "all";
    let selectedChannelId = "all";
    // Keep track of build-time filters for validation
    const uniqueYears = initialUniqueYears.map(y => y); // Simple clone
    const uniqueChannels = initialUniqueChannels.map(c => ({ ...c })); // Simple clone


    function updateUrl() {
        const url = new URL(window.location.href);
        url.searchParams.set("page", currentPage.toString());
        url.searchParams.set("limit", itemsPerPage.toString());
        url.searchParams.set("year", selectedYear);
        url.searchParams.set("channel", selectedChannelId);
        // Use pushState to change URL without reloading
        history.pushState({}, "", url.toString());
    }

    function renderPage() {
         // console.log("Render page called. Loading:", isDataLoading, "Data length:", allVideos.length);

        if (
            !gridContainer || !pageSelect || !pageTotalSpan || !prevButton || !nextButton ||
            !limitSelect || !yearSelect || !channelSelect || !loadingIndicator
        ) return;

        // Show loading indicator if data isn't ready
        loadingIndicator.classList.toggle("hidden", !isDataLoading);
        gridContainer.classList.toggle("grid", !isDataLoading); // Ensure grid is applied only when loaded


        if (isDataLoading) {
            // If still loading, ensure pagination/filters are disabled
            pageSelect.disabled = true;
            pageTotalSpan.textContent = "of ?";
            prevButton.classList.add("disabled");
            prevButton.setAttribute("aria-disabled", "true");
            nextButton.classList.add("disabled");
            nextButton.setAttribute("aria-disabled", "true");
            limitSelect.disabled = true;
            yearSelect.disabled = true;
            channelSelect.disabled = true;
            if (removeFiltersButton) removeFiltersButton.disabled = true;
            gridContainer.innerHTML = ''; // Clear any previous grid content
            gridContainer.appendChild(loadingIndicator); // Make sure indicator is inside grid area
            return; // Don't proceed further until data is loaded
        }

        // --- Data Loaded ---
        // Enable controls now that data is loaded
        limitSelect.disabled = false;
        yearSelect.disabled = false;
        channelSelect.disabled = false;
        pageSelect.disabled = totalPages <= 1; // Disable if only one page
        if (removeFiltersButton) removeFiltersButton.disabled = false;


        // --- Apply Filters ---
        let filteredVideos = allVideos;
        if (selectedYear !== "all") {
            filteredVideos = filteredVideos.filter((video) =>
                video.published_at && video.published_at.startsWith(selectedYear),
            );
        }
        if (selectedChannelId !== "all") {
            filteredVideos = filteredVideos.filter(
                (video) => video.video_owner_channel_id === selectedChannelId,
            );
        }
        // --- End Apply Filters ---

        const currentTotalItems = filteredVideos.length;
        totalPages = Math.ceil(currentTotalItems / itemsPerPage);
        currentPage = Math.max(1, Math.min(currentPage, totalPages > 0 ? totalPages : 1));

        const offset = (currentPage - 1) * itemsPerPage;
        const videosToShow = filteredVideos.slice(offset, offset + itemsPerPage);
        const maxLength = 40; // Max characters for title

        // Generate grid HTML or "No results" message
        if (videosToShow.length > 0) {
            gridContainer.innerHTML = videosToShow
                .map((video) => {
                    // Ensure title is a string, provide fallback
                    const title = typeof video.title === 'string' ? video.title : 'Untitled Video';
                    let displayTitle = title;
                    if (displayTitle.length > maxLength) {
                        const lastSpace = displayTitle.lastIndexOf(" ", maxLength - 1);
                        displayTitle = (lastSpace > maxLength / 2)
                            ? displayTitle.substring(0, lastSpace) + "…"
                            : displayTitle.substring(0, maxLength - 1) + "…";
                    }

                    const imageUrl = video.thumbnail_url;
                    // Ensure imageUrl is a string and looks like a valid URL before using it in <img>
                    const isValidImageUrl = typeof imageUrl === 'string' && imageUrl.trim() !== '' && imageUrl.startsWith('http');
                    const imageHtml = isValidImageUrl
                            ? `<img src="${imageUrl}" alt="${title}" loading="lazy" class="w-full aspect-video object-cover block"/>`
                            : `<div class="w-full aspect-video bg-gray-200 dark:bg-gray-600 flex items-center justify-center"><span class="text-xs text-gray-500 dark:text-gray-400">No Thumbnail</span></div>`;

                    // Ensure url is a string, provide fallback
                     const videoUrl = typeof video.url === 'string' ? video.url : '#';

                    return `
                <a href="${videoUrl}" target="_blank" rel="noopener noreferrer" class="flex flex-col no-underline text-inherit rounded-lg overflow-hidden shadow-md hover:shadow-xl hover:-translate-y-1 transition duration-200 ease-in-out" title="${title}">
                    ${imageHtml}
                    <p class="px-3 pt-3 pb-4 text-sm m-0 leading-tight">${displayTitle}</p>
                </a>
            `;
                })
                .join("");
        } else {
            gridContainer.innerHTML = `
                <div class="col-span-full text-center py-10">
                    <p class="text-lg text-[color:var(--text-secondary)]">No videos match your filters.<br>Try removing a filter.</p>
                </div>`;
        }

        // --- Update Page Select Dropdown --- 
        pageTotalSpan.textContent = `of ${totalPages > 0 ? totalPages : 1}`;
        // Populate dropdown options
        pageSelect.innerHTML = ''; // Clear previous options
        const maxOptionsToShow = 500; // Limit options for performance if totalPages is huge
        for (let i = 1; i <= Math.min(totalPages, maxOptionsToShow); i++) {
            const option = document.createElement('option');
            option.value = i.toString();
            option.textContent = i.toString();
            pageSelect.appendChild(option);
        }
        if (totalPages > maxOptionsToShow) {
             const option = document.createElement('option');
             option.value = currentPage.toString(); // Ensure current is selectable if > max
             option.textContent = `${currentPage} (current)`;
             option.disabled = true; // Visually indicate it might be outside normal range
             pageSelect.appendChild(option);
             console.warn(`Page dropdown limited to first ${maxOptionsToShow} options due to large number of pages.`);
        }
        pageSelect.value = currentPage.toString();
        pageSelect.disabled = totalPages <= 1; // Re-evaluate disable state
        // --- End Update Page Select --- 

        // --- Show/Hide Remove Filters Button ---
        if (removeFiltersButton) {
            const filtersActive = selectedYear !== "all" || selectedChannelId !== "all";
            removeFiltersButton.classList.toggle("hidden", !filtersActive);
        }

        // Update button states
        const hasPrev = currentPage > 1 && totalPages > 0;
        const hasNext = currentPage < totalPages && totalPages > 0;

        prevButton.classList.toggle("disabled", !hasPrev);
        prevButton.setAttribute("aria-disabled", (!hasPrev).toString());

        nextButton.classList.toggle("disabled", !hasNext);
        nextButton.setAttribute("aria-disabled", (!hasNext).toString());

        // Ensure dropdowns reflect current state (might have been set by URL initially)
        limitSelect.value = itemsPerPage.toString();
        yearSelect.value = selectedYear;
        channelSelect.value = selectedChannelId;
    }

    function handleNavClick(event, newPage) {
        event.preventDefault();
        if (isDataLoading) return; // Don't navigate if data isn't loaded

        // Recalculate total pages based on current filters *before* checking bounds
        let currentFilteredVideos = allVideos;
        if (selectedYear !== "all") {
             currentFilteredVideos = currentFilteredVideos.filter(v => v.published_at && v.published_at.startsWith(selectedYear));
        }
        if (selectedChannelId !== "all") {
            currentFilteredVideos = currentFilteredVideos.filter(v => v.video_owner_channel_id === selectedChannelId);
        }
        const currentTotalItems = currentFilteredVideos.length;
        const currentTotalPages = Math.ceil(currentTotalItems / itemsPerPage);


        if (newPage < 1 || newPage > (currentTotalPages > 0 ? currentTotalPages : 1)) return;

        currentPage = newPage;
        updateUrl();
        renderPage();
    }

    async function initializeAndFetchData() {
        // console.log("Initializing and fetching data...");
        isDataLoading = true;
        if (errorMessageElement) errorMessageElement.classList.add('hidden'); // Hide previous errors
        renderPage(); // Show initial loading state

        try {
            // console.log(`Fetching from: ${jsonUrl}`);
            const response = await fetch(jsonUrl);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
             // console.log(`Fetched ${data.length} videos.`);

            if (!Array.isArray(data)) {
                 throw new Error("Fetched data is not an array.");
            }

            // --- Data Validation (Optional but Recommended) ---
            // Simple check on the first item if available
            if (data.length > 0) {
                 const firstItem = data[0];
                 if (typeof firstItem.title === 'undefined' || typeof firstItem.url === 'undefined') {
                     console.warn("Fetched data structure seems incorrect. Missing 'title' or 'url' in the first item.");
                     // Potentially throw an error or handle differently
                 }
            }
             // --- End Validation ---

            allVideos = data; // Store fetched data globally
            // Filter out videos titled "Private Video"
            allVideos = allVideos.filter(video => video.title !== "Private video");

            isDataLoading = false; // Mark loading as complete

            // --- Set Initial State from URL AFTER data load ---
        const urlParams = new URLSearchParams(window.location.search);
        const initialPage = parseInt(urlParams.get("page") || "1");
             const initialLimit = parseInt(urlParams.get("limit") || validLimits[0].toString());
        const initialYear = urlParams.get("year") || "all";
        const initialChannel = urlParams.get("channel") || "all";

        // Set Limit
             if (validLimits.includes(initialLimit)) {
            itemsPerPage = initialLimit;
        } else {
                 itemsPerPage = validLimits[0];
        }
             limitSelect.value = itemsPerPage.toString();

             // Set Year Filter (Validate against build-time filters)
        if (initialYear === "all" || uniqueYears.includes(initialYear)) {
            selectedYear = initialYear;
        } else {
                  selectedYear = "all";
        }
        yearSelect.value = selectedYear;

             // Set Channel Filter (Validate against build-time filters)
        const validChannelIds = ["all", ...uniqueChannels.map((c) => c.id)];
        if (validChannelIds.includes(initialChannel)) {
            selectedChannelId = initialChannel;
        } else {
                  selectedChannelId = "all";
        }
        channelSelect.value = selectedChannelId;

        // Apply filters to determine initial total pages before setting current page
        let initialFilteredVideos = allVideos;
        if (selectedYear !== "all") {
                  initialFilteredVideos = initialFilteredVideos.filter(v => v.published_at && v.published_at.startsWith(selectedYear));
        }
        if (selectedChannelId !== "all") {
                  initialFilteredVideos = initialFilteredVideos.filter(v => v.video_owner_channel_id === selectedChannelId);
              }
              const initialFilteredTotalItems = initialFilteredVideos.length;
              totalPages = Math.ceil(initialFilteredTotalItems / itemsPerPage);

              // Set Current Page (Validate against calculated total pages)
              if (initialPage >= 1 && initialPage <= (totalPages > 0 ? totalPages : 1)) {
            currentPage = initialPage;
        } else {
                   currentPage = 1;
              }

            // --- End Set Initial State ---

            renderPage(); // First render with actual data
            updateUrl(); // Sync URL
            setupEventListeners(); // Add listeners now that data is ready

        } catch (error) {
            console.error("Failed to fetch or process video data:", error);
            isDataLoading = false; // Stop loading state
             if (loadingIndicator) loadingIndicator.classList.add('hidden'); // Hide spinner
             if (errorMessageElement) {
                errorMessageElement.textContent = `Error loading videos: ${error.message}. Please try refreshing.`;
                errorMessageElement.classList.remove('hidden'); // Show error message
             }
            // Optionally disable controls or show a persistent error message in the grid
            gridContainer.innerHTML = `<div class="col-span-full text-center py-10 text-red-600">Failed to load videos.</div>`;
             // Disable controls on error
             if (limitSelect) limitSelect.disabled = true;
             if (yearSelect) yearSelect.disabled = true;
             if (channelSelect) channelSelect.disabled = true;
             if (removeFiltersButton) removeFiltersButton.disabled = true;
             if (prevButton) prevButton.classList.add("disabled"); prevButton.setAttribute("aria-disabled", "true");
             if (nextButton) nextButton.classList.add("disabled"); nextButton.setAttribute("aria-disabled", "true");
             if (pageSelect) pageSelect.disabled = true;
             if (pageTotalSpan) pageTotalSpan.textContent = "of ?";
        }
    }


    function setupEventListeners() {
        // console.log("Setting up event listeners...");
        if (!limitSelect || !yearSelect || !channelSelect || !prevButton || !nextButton || !pageSelect) return;

        // Helper to replace listeners (avoids duplicates on HMR/popstate)
        const replaceListener = (element, eventType, newHandler) => {
            if (element._handler) {
                element.removeEventListener(eventType, element._handler);
            }
            element.addEventListener(eventType, newHandler);
            element._handler = newHandler;
        };

        const handleYearChange = (event) => {
            const target = event.target;
            if (target && "value" in target) {
                selectedYear = target.value;
                currentPage = 1;
                updateUrl();
                renderPage();
            }
        };
        replaceListener(yearSelect, "change", handleYearChange);

        const handleChannelChange = (event) => {
            const target = event.target;
            if (target && "value" in target) {
                selectedChannelId = target.value;
                currentPage = 1;
                updateUrl();
                renderPage();
            }
        };
        replaceListener(channelSelect, "change", handleChannelChange);

        const handleLimitChange = (event) => {
            const target = event.target;
            if (target && "value" in target) {
                const newLimit = parseInt(target.value);
                if (validLimits.includes(newLimit)) {
                    itemsPerPage = newLimit;
                    currentPage = 1;
                    updateUrl();
                    renderPage();
                }
            }
        };
        replaceListener(limitSelect, "change", handleLimitChange);

        const handlePrevClick = (event) => handleNavClick(event, currentPage - 1);
        replaceListener(prevButton, "click", handlePrevClick);

        const handleNextClick = (event) => handleNavClick(event, currentPage + 1);
        replaceListener(nextButton, "click", handleNextClick);

        const handleRemoveFilters = (event) => {
            event.preventDefault();
            selectedYear = "all";
            selectedChannelId = "all";
            currentPage = 1;
            updateUrl();
            renderPage();
        };
        if (removeFiltersButton) {
            replaceListener(removeFiltersButton, "click", handleRemoveFilters);
        }

        // --- Page Select Listener ---
         const handlePageSelectChange = (event) => {
            const target = event.target;
             if (target && "value" in target) {
                const newPage = parseInt(target.value);
                 if (!isNaN(newPage) && newPage >= 1 && newPage <= totalPages) {
                     currentPage = newPage;
                     updateUrl();
                     renderPage();
                 }
            }
        };
        replaceListener(pageSelect, "change", handlePageSelectChange);
        // --- End Page Select Listener ---

        // Handle browser back/forward buttons
        if (!window._popstateHandledVideos) {
            window.addEventListener("popstate", () => {
                 // console.log("Popstate triggered, re-initializing from URL.");
                 // Re-read URL and set state, then render (no re-fetch needed)
                 const urlParams = new URLSearchParams(window.location.search);
                 const popPage = parseInt(urlParams.get("page") || "1");
                 const popLimit = parseInt(urlParams.get("limit") || validLimits[0].toString());
                 const popYear = urlParams.get("year") || "all";
                 const popChannel = urlParams.get("channel") || "all";

                 // Set state directly from URL
                 currentPage = popPage;
                 itemsPerPage = validLimits.includes(popLimit) ? popLimit : validLimits[0];
                 selectedYear = (popYear === "all" || uniqueYears.includes(popYear)) ? popYear : "all";
                 const validChannelIds = ["all", ...uniqueChannels.map((c) => c.id)];
                 selectedChannelId = validChannelIds.includes(popChannel) ? popChannel : "all";

                 if (!isDataLoading) { // Only render if data is actually loaded
                    renderPage();
                 } else {
                     // If popstate happens before initial load finishes,
                     // the initializeAndFetchData function will handle the URL params correctly when it finishes.
                     console.log("Popstate occurred before initial data load finished.");
                 }

            });
            window._popstateHandledVideos = true;
        }
    }

    // Start the process
    initializeAndFetchData();

</script>

<style is:global>
    /* Thin scrollbar for #page-select in Webkit browsers */
    #page-select::-webkit-scrollbar {
      width: 5px;
    }

    #page-select::-webkit-scrollbar-track {
      background: transparent;
    }

    #page-select::-webkit-scrollbar-thumb {
      background-color: var(--text-secondary);
      border-radius: 10px;
      border: none;
    }

    /* Thin scrollbar for #page-select in Firefox */
    #page-select {
      scrollbar-width: thin;
      scrollbar-color: var(--text-secondary) transparent;
    }
</style>
